---
layout:     post
title:      学习笔记： 硬件接口详解
subtitle:   Learning Notes
date:       2020-04-26
author:     MZ
header-img: img/post-bg-Reading-cyydcx.jpg
catalog: true
tags:
    - Learning Notes

---

# 硬件接口详解

> 记录硬件工程师常用的接口知识，方便深入理解

## 串行

### 1. UART

通用异步收发传输器（Universal Asynchronous Receiver/Transmitter)，通常称作UART。

UART是个大家族，包括了RS232、RS499、RS423、RS422和RS485等接口标准规范和总线标准规范。它们的主要区别在于其各自的电平范围不相同。

嵌入式设备中常常使用到的是TTL、TTL转RS232的这种方式。常用的就三根引线：发送线TX、接收线RX、电平参考地线GND。

UART作为异步串口通信协议的一种，工作原理是将传输数据的每个字符一位一位地传输。其中，各位的意义如下：

- **起始位：**先发出一个逻辑“0”的信号，表示传输字符的开始。

- **数据位：**紧接着起始位之后。数据位的个数可以是4、5、6、7、8等，构成一个字符。通常采用ASCII码。

- **奇偶校验位：**数据位加上这一位后(数据和校验位)，使得“1”的位数应为偶数（偶校验）或奇校验（奇校验），以此来校验资料的传送正确性。**工程上利用归约异或的结果作为偶校验，奇校验则取反。**

- **停止位：**它是一个字符数据的结束标志。可以是1位、1.5位、2位的高电平。
- **空闲位：**处于逻辑“1”的状态，表示当前线路上没有资料传输。

![JcXaxs.png](https://s1.ax1x.com/2020/04/26/JcXaxs.png)



数据传输速率用波特率表示，即每秒传送的二进制位数。例如数据传输速率为120字符/秒，而每一个字符为10位（1个起始位，7个数据位，1个校验位，1个结束位），则波特率为10*120=1200

**UART抛开了clock信号，通过采样的方式进行识别，所以在数据传输的双方需要定义统一波特率，以便正确的传输数据。**

**FPGA程序设计**

对于FPGA设计，主要有三个模块组成：**波特率发生模块、发送模块，接收模块**组成。

1. **波特率发生模块**

   设计的UART的接收和发送按照相同的波特率进行，FPGA 主频如果为50M，则时钟周期就是20ns。若数据发送速率为9600bps，则一位数据需要的时间为1000000000/9600=104167ns，则FPGA 传送一位需要翻转104167/20=5208个周期才可传送一位，所以程序中需计数5208才可满足9600bps。

   简单一点就是**时钟频率除以波特率**就是需要的计数。

   参考代码：（转载自https://github.com/halftop/Interface-Protocol-in-Verilog/tree/master/general_uart 感谢）

   ```verilog
   `timescale 1ns / 1ps
   module tx_clk_gen
   #(
       parameter   CLK_FREQUENCE   = 50_000_000,       //hz
                   BAUD_RATE       = 9600              //9600、19200 、38400 、57600 、115200、230400、460800、921600
   )
   (
       input                   clk         ,   //system_clk
       input                   rst_n       ,   //system_reset
       input                   tx_done     ,   //once_tx_done
       input                   tx_start    ,   //once_tx_start
       output  reg             bps_clk         //baud_rate_clk
   );
    
   localparam  BPS_CNT =   CLK_FREQUENCE/BAUD_RATE-1,
               BPS_WD  =   log2(BPS_CNT);
    
   reg [BPS_WD-1:0] count;
   reg c_state;
   reg n_state;
   //FSM-1         1'b0:IDLE   1'b1:send_data
   always @(posedge clk or negedge rst_n) begin
       if (!rst_n)
           c_state <= 1'b0;
       else
           c_state <= n_state;
   end
   //FSM-2
   always @(*) begin
       case (c_state)
           1'b0: n_state = tx_start ? 1'b1 : 1'b0;
           1'b1: n_state = tx_done ? 1'b0 : 1'b1;
           default: n_state = 1'b0;
       endcase
   end
   //FSM-3 FSM's output(count_en) is equal to c_state
    
   //baud_rate_clk_counter
   always @(posedge clk or negedge rst_n) begin
       if (!rst_n)
           count <= {BPS_WD{1'b0}};
       else if (!c_state)
           count <= {BPS_WD{1'b0}};
       else begin
           if (count == BPS_CNT) 
               count <= {BPS_WD{1'b0}};
           else
               count <= count + 1'b1;
       end
   end
   //baud_rate_clk_output
   always @(posedge clk or negedge rst_n) begin
       if (!rst_n)
           bps_clk <= 1'b0;
       else if (count == 'd1)
           bps_clk <= 1'b1;
       else
           bps_clk <= 1'b0;
   end
   //get_the_width_of_
   function integer log2(input integer v);
     begin
       log2=0;
       while(v>>log2) 
         log2=log2+1;
     end
   endfunction
    
   endmodule
   ```

   **重点关注以上代码的log2函数。**

2. **数据帧发送模块**：

   支持通过参数设定波特率、奇偶检验位及数据位宽。采用状态机和移位寄存器实现。当有校验位时则发送检验位；若没有校验位则直接发送停止位（发送两次停止位），如下所示。

   ```verilog
   `timescale 1ns / 1ps
   module uart_frame_tx
   #(
       parameter   CLK_FREQUENCE   = 50_000_000,       //hz
                   BAUD_RATE       = 9600      ,       //9600、19200 、38400 、57600 、115200、230400、460800、921600
                   PARITY          = "NONE"    ,       //"NONE","EVEN","ODD"
                   FRAME_WD        = 8                 //if PARITY="NONE",it can be 5~9;else 5~8
   )
   (
       input                       clk         ,   //system_clk
       input                       rst_n       ,   //system_reset
       input                       frame_en    ,   //once_tx_start
       input       [FRAME_WD-1:0]  data_frame  ,   //data_to_tx
       output  reg                 tx_done     ,   //once_tx_done
       output  reg                 uart_tx         //uart_tx_data
   );
    
   wire    bps_clk;
    
   tx_clk_gen
   #(
       .CLK_FREQUENCE  (CLK_FREQUENCE),        //hz
       .BAUD_RATE      (BAUD_RATE  )           //9600、19200 、38400 、57600 、115200、230400、460800、921600
   )
   tx_clk_gen_inst
   (
       .clk            ( clk        ),     //system_clk
       .rst_n          ( rst_n      ),     //system_reset
       .tx_done        ( tx_done    ),     //once_tx_done
       .tx_start       ( frame_en   ),     //once_tx_start
       .bps_clk        ( bps_clk    )      //baud_rate_clk
   );
    
   localparam  IDLE        =   6'b00_0000  ,
               READY       =   6'b00_0001  ,
               START_BIT   =   6'b00_0010  ,
               SHIFT_PRO   =   6'b00_0100  ,
               PARITY_BIT  =   6'b00_1000  ,
               STOP_BIT    =   6'b01_0000  ,
               DONE        =   6'b10_0000  ;
    
   wire    [1:0]   verify_mode;
   generate
       if (PARITY == "ODD")
           assign verify_mode = 2'b01;
       else if (PARITY == "EVEN")
           assign verify_mode = 2'b10;
       else
           assign verify_mode = 2'b00;
   endgenerate
    
   reg     [FRAME_WD-1:0]  data_reg    ;
   reg     [log2(FRAME_WD-1)-1:0] cnt  ;
   reg                     parity_even ;
   reg     [5:0]           cstate      ;
   reg     [5:0]           nstate      ;
    
   always @(posedge clk or negedge rst_n) begin
       if (!rst_n)
           cnt <= 'd0;
       else if (cstate == SHIFT_PRO & bps_clk == 1'b1) 
           if (cnt == FRAME_WD-1)
               cnt <= 'd0;
           else
               cnt <= cnt + 1'b1;
       else
           cnt <= cnt;
   end
   //FSM-1
   always @(posedge clk or negedge rst_n) begin
       if (!rst_n)
           cstate <= IDLE;
       else
           cstate <= nstate;
   end
   //FSM-2
   always @(*) begin
       case (cstate)
           IDLE        : nstate = frame_en ? READY : IDLE  ;
           READY       : nstate = (bps_clk == 1'b1) ? START_BIT : READY;
           START_BIT   : nstate = (bps_clk == 1'b1) ? SHIFT_PRO : START_BIT;
           SHIFT_PRO   : nstate = (cnt == FRAME_WD-1 & bps_clk == 1'b1) ? PARITY_BIT : SHIFT_PRO;
           PARITY_BIT  : nstate = (bps_clk == 1'b1) ? STOP_BIT : PARITY_BIT;
           STOP_BIT    : nstate = (bps_clk == 1'b1) ? DONE : STOP_BIT;
           DONE        : nstate = IDLE;
           default     : nstate = IDLE;
       endcase
   end
   //FSM-3
   always @(posedge clk or negedge rst_n) begin
       if (!rst_n) begin
           data_reg <= 'd0;
           uart_tx <= 1'b1;
           tx_done <= 1'b0;
           parity_even <= 1'b0;
       end else begin
           case (nstate)
               IDLE        : begin
                               data_reg <= 'd0;
                               tx_done <= 1'b0;
                               uart_tx <= 1'b1;
                           end
               READY       : begin
                               data_reg <= 'd0;
                               tx_done <= 1'b0;
                               uart_tx <= 1'b1;
                           end
               START_BIT   : begin
                               data_reg <= data_frame;
                               parity_even <= ^data_frame;     //生成偶校验位
                               uart_tx <= 1'b0;
                               tx_done <= 1'b0;
                           end
               SHIFT_PRO   : begin
                               if(bps_clk == 1'b1) begin
                                   data_reg <= {1'b0,data_reg[FRAME_WD-1:1]};
                                   uart_tx <= data_reg[0];
                               end else begin
                                   data_reg <= data_reg;
                                   uart_tx <= uart_tx;
                               end
                               tx_done <= 1'b0;
                           end
               PARITY_BIT  : begin
                               data_reg <= data_reg;
                               tx_done <= 1'b0;
                               case (verify_mode)
                                   2'b00: uart_tx <= 1'b1;     //若无校验多发一位STOP_BIT
                                   2'b01: uart_tx <= ~parity_even;
                                   2'b10: uart_tx <= parity_even;
                                   default: uart_tx <= 1'b1;
                               endcase
                           end
               STOP_BIT    : uart_tx <= 1'b1;
               DONE        : tx_done <= 1'b1;
               default     :  begin
                               data_reg <= 'd0;
                               uart_tx <= 1'b1;
                               tx_done <= 1'b0;
                               parity_even <= 1'b0;
                           end
           endcase
       end
   end
    
   function integer log2(input integer v);
     begin
       log2=0;
       while(v>>log2) 
         log2=log2+1;
     end
   endfunction
    
   endmodule
   ```

   数据接收模块设计如下：

   ```verilog
   module uart_frame_rx
   #(
       parameter   CLK_FREQUENCE   = 50_000_000,       //hz
                   BAUD_RATE       = 9600      ,       //9600、19200 、38400 、57600 、115200、230400、460800、921600
                   PARITY          = "NONE"    ,       //"NONE","EVEN","ODD"
                   FRAME_WD        = 8                 //if PARITY="NONE",it can be 5~9;else 5~8
   )
   (
       input                       clk         ,       //sys_clk
       input                       rst_n       ,       
       input                       uart_rx     ,       
       output  reg [FRAME_WD-1:0]  rx_frame    ,       //frame_received,when rx_done = 1 it's valid
       output  reg                 rx_done     ,       //once_rx_done
       output  reg                 frame_error         //when the PARITY is enable if frame_error = 1,the frame received is wrong
   );
    
   wire            sample_clk      ;
   wire            frame_en        ;       //once_rx_start
   reg             cnt_en          ;       //sample_clk_cnt enable
   reg     [3:0]   sample_clk_cnt  ;       
   reg     [log2(FRAME_WD+1)-1:0]      sample_bit_cnt  ;
   wire            baud_rate_clk   ;
    
   localparam  IDLE        =   5'b0_0000,
               START_BIT   =   5'b0_0001,
               DATA_FRAME  =   5'b0_0010,
               PARITY_BIT  =   5'b0_0100,
               STOP_BIT    =   5'b0_1000,
               DONE        =   5'b1_0000;
    
   reg [4:0]   cstate;
   reg [4:0]   nstate;
   //
   wire    [1:0]   verify_mode;
   generate
       if (PARITY == "ODD")
           assign verify_mode = 2'b01;
       else if (PARITY == "EVEN")
           assign verify_mode = 2'b10;
       else
           assign verify_mode = 2'b00;
   endgenerate
   //detect the start condition--the negedge of uart_rx
   reg     uart_rx0,uart_rx1,uart_rx2,uart_rx3;
    
   always @(posedge clk or negedge rst_n) begin
       if (!rst_n) begin
           uart_rx0 <= 1'b0;
           uart_rx1 <= 1'b0;
           uart_rx2 <= 1'b0;
           uart_rx3 <= 1'b0;
       end else begin
           uart_rx0 <= uart_rx ;
           uart_rx1 <= uart_rx0;
           uart_rx2 <= uart_rx1;
           uart_rx3 <= uart_rx2;
       end
   end
   //negedge of uart_rx-----start_bit
   assign frame_en = uart_rx3 & uart_rx2 & ~uart_rx1 & ~uart_rx0;
    
   always @(posedge clk or negedge rst_n) begin
       if (!rst_n) 
           cnt_en <= 1'b0;
       else if (frame_en) 
           cnt_en <= 1'b1;
       else if (rx_done) 
           cnt_en <= 1'b0;
       else
           cnt_en <= cnt_en;
   end
    
   assign baud_rate_clk = sample_clk & sample_clk_cnt == 4'd8;
    
   always @(posedge clk or negedge rst_n) begin
       if (!rst_n) 
           sample_clk_cnt <= 4'd0;
       else if (cnt_en) begin
           if (baud_rate_clk) 
               sample_clk_cnt <= 4'd0;
           else if (sample_clk)
               sample_clk_cnt <= sample_clk_cnt + 1'b1;
           else
               sample_clk_cnt <= sample_clk_cnt;
       end else 
           sample_clk_cnt <= 4'd0;
   end
   //the start_bit is the first one (0),then the LSB of the data_frame is the second(1) ......
   always @(posedge clk or negedge rst_n) begin
       if (!rst_n) 
           sample_bit_cnt <= 'd0;
       else if (cstate == IDLE)
           sample_bit_cnt <= 'd0;
       else if (baud_rate_clk)
           sample_bit_cnt <= sample_bit_cnt + 1'b1;
       else
           sample_bit_cnt <= sample_bit_cnt;
   end
   //read the readme
   reg     [1:0]   sample_result   ;
   always @(posedge clk or negedge rst_n) begin
       if (!rst_n) 
           sample_result <= 1'b0;
       else if (sample_clk) begin
           case (sample_clk_cnt)
               4'd0:sample_result <= 2'd0;
               4'd3,4'd4,4'd5: sample_result <= sample_result + uart_rx;
               default: sample_result <= sample_result;
           endcase
       end
   end
   //FSM-1
   always @(posedge clk or negedge rst_n) begin
       if (!rst_n) 
           cstate <= IDLE;
       else 
           cstate <= nstate;
   end
   //FSM-2
   always @(*) begin
       case (cstate)
           IDLE        : nstate = frame_en ? START_BIT : IDLE ;
           START_BIT   : nstate = (baud_rate_clk & sample_result[1] == 1'b0) ? DATA_FRAME : START_BIT ;
           DATA_FRAME  : begin
                           case (verify_mode[1]^verify_mode[0])
                               1'b1: nstate = (sample_bit_cnt == FRAME_WD & baud_rate_clk) ? PARITY_BIT : DATA_FRAME ;     //parity is enable
                               1'b0: nstate = (sample_bit_cnt == FRAME_WD & baud_rate_clk) ? STOP_BIT : DATA_FRAME ;       //parity is disable
                               default: nstate = (sample_bit_cnt == FRAME_WD & baud_rate_clk) ? STOP_BIT : DATA_FRAME ;    //defasult is disable
                           endcase
                       end
           PARITY_BIT  : nstate = baud_rate_clk ? STOP_BIT : PARITY_BIT ;
           STOP_BIT    : nstate = (baud_rate_clk & sample_result[1] == 1'b1) ? DONE : STOP_BIT ;
           DONE        : nstate = IDLE;
           default: nstate = IDLE;
       endcase
   end
   //FSM-3
   always @(posedge clk or negedge rst_n) begin
       if (!rst_n) begin
           rx_frame    <= 'd0;
           rx_done     <= 1'b0;
           frame_error <= 1'b0;
       end else begin
           case (nstate)
               IDLE        : begin
                               rx_frame    <= 'd0;
                               rx_done     <= 1'b0;
                               frame_error <= 1'b0;
                           end 
               START_BIT   : begin
                               rx_frame    <= 'd0;
                               rx_done     <= 1'b0;
                               frame_error <= 1'b0;
                           end 
               DATA_FRAME  : begin
                               if (sample_clk & sample_clk_cnt == 4'd6) 
                                   rx_frame <= {sample_result[1],rx_frame[FRAME_WD-1:1]};
                               else
                                   rx_frame    <= rx_frame;
                               rx_done     <= 1'b0;
                               frame_error <= 1'b0;
                           end 
               PARITY_BIT  : begin
                               rx_frame    <= rx_frame;
                               rx_done     <= 1'b0;
                               if (sample_clk_cnt == 4'd8)
                               frame_error <= ^rx_frame ^ sample_result[1];
                               else
                               frame_error <= frame_error;
                           end 
               STOP_BIT    : begin
                               rx_frame    <= rx_frame;
                               rx_done     <= 1'b0;
                               frame_error <= frame_error;
                           end 
               DONE        : begin
                               frame_error <= frame_error;
                               rx_done     <= 1'b1;
                               rx_frame    <= rx_frame;
                           end 
               default: begin
                               rx_frame    <= rx_frame;
                               rx_done     <= 1'b0;
                               frame_error <= frame_error;
                           end 
           endcase
       end
   end
    
   rx_clk_gen
   #(
       .CLK_FREQUENCE  (CLK_FREQUENCE  ),  //hz
       .BAUD_RATE      (BAUD_RATE      )   //9600、19200 、38400 、57600 、115200、230400、460800、921600
   )
   rx_clk_gen_inst
   (
       .clk            ( clk        )  ,
       .rst_n          ( rst_n      )  ,
       .rx_start       ( frame_en   )  ,
       .rx_done        ( rx_done    )  ,
       .sample_clk     ( sample_clk )  
   );  
    
   function integer log2(input integer v);
     begin
       log2=0;
       while(v>>log2) 
         log2=log2+1;
     end
   endfunction
   endmodule
   ```

   根据uart协议，数据传输线空闲时位高电平，数据传输以一位低电平的起始位开始，因此**准确检测起始位是数据成功传输的关键**。由于接受端和发送端是异步的，**需要专门的边沿检测电路来捕捉下降沿**。这里采用4个移位寄存器，连续采集4个时钟上升沿时的数据，通过对比前两个时刻和后两个时刻的数据线的状态来得到数据线准确的下降沿，获得准确的开始接收条件。

   在简单的串口接收中，我们通常选取一位数据的中间时刻进行采样，因为此时数据最稳定，但是在工业环境中，存在着各种干扰，在干扰存在的情况下，**如果采用传统的中间时刻采样一次的方式，采样结果就有可能受到干扰而出错**。为了滤除这种干扰，这里采用多次采样求概率的方式。如下图，将一位数据平均分成9个时间段，对位于中间的三个时间段进行采样。然后对三个采样结果进行统计判断，**如果某种电平状态在三次采样结果中占到了两次及以上，则可以判定此电平状态即为正确的数据电平。**例如4、5、6时刻采样结果分别为1、1、0，那么就取此位解码结果为1，否则，若三次采样结果为0、1、0，则解码结果就为0。即3次采样为a,b,c，则结果为`a&b | b&c |a&c`，显而易见此结果是**全加器的进位**。

   ![数据采样示例](https://i.loli.net/2019/06/11/5cffa2289f6cb31791.png)

   **所以采样时钟应该是波特率时钟的9倍！**

   ```verilog
   `timescale 1ns / 1ps
    
   module rx_clk_gen
   #(
       parameter   CLK_FREQUENCE   = 50_000_000,   //hz
                   BAUD_RATE       = 9600          //9600、19200 、38400 、57600 、115200、230400、460800、921600
   )
   (
       input                   clk         ,
       input                   rst_n       ,
       input                   rx_start    ,
       input                   rx_done     ,
       output  reg             sample_clk   
   );
    
   localparam  SMP_CLK_CNT =   CLK_FREQUENCE/BAUD_RATE/9 - 1,
               CNT_WIDTH   =   log2(SMP_CLK_CNT)            ;
    
   reg     [CNT_WIDTH-1:0] clk_count   ;
   reg     cstate;
   reg     nstate;
   //FSM-1 1'b0:IDLE 1'b1:RECEIVE
   always @(posedge clk or negedge rst_n) begin
       if (!rst_n) begin
           cstate <= 1'b0;
       end else begin
           cstate <= nstate;
       end
   end
   //FSM-2
   always @(*) begin
       case (cstate)
           1'b0: nstate = rx_start ? 1'b1 : 1'b0;
           1'b1: nstate = rx_done ? 1'b0 : 1'b1 ;
           default: nstate = 1'b0;
       endcase
   end
   //FSM-3 FSM's output(clk_count_en) is equal to cstate
    
   //sample_clk_counter
   always @(posedge clk or negedge rst_n) begin
       if (!rst_n) 
           clk_count <= 'd0;
       else if (!cstate) 
           clk_count <= 'd0;
       else if (clk_count == SMP_CLK_CNT)
           clk_count <= 'd0;
       else
           clk_count <= clk_count + 1'b1;
   end
   //generate sample_clk = 9xBAUD_RATE
   always @(posedge clk or negedge rst_n) begin
       if (!rst_n) 
           sample_clk <= 1'b0;
       else if (clk_count == 1'b1) 
           sample_clk <= 1'b1;
       else 
           sample_clk <= 1'b0;
   end
   //get the width of sample_clk_counter
   function integer log2(input integer v);
     begin
       log2=0;
       while(v>>log2) 
         log2=log2+1;
     end
   endfunction
    
   endmodule
   ```

   UART模块内容多参考了halftop大神的代码，思考全面代码整洁，感谢。

### 2. IIC总线

IIC（Inter-Integrated Circuit）。一种串行数据总线，只有两根信号线，一根是双向的数据线SDA，另一根是时钟线SCL。两条线可以挂多个设备。IIC设备（绝大多数）具有固化的地址，只有在两条线上传输的值等于IIC设备的固化地址时，其才会作出响应。通常我们为了方便把IIC设备分为主设备和从设备，基本上谁控制时钟线（即控制SCL的电平高低变换）谁就是主设备。

当没有数据传输时，两根总线均为高电平，当采集IIC上的数据时，其时钟线SCL必须是高电平且SDA的数据必须保持稳定不变——将SDA的电平与SCL的高电平进行“与”操作后，以便确定SDA上是1还是0；在SCL为低电平的时候，SDA上的数据可以进行跳变。

数据传输开始时，需要发送一个起始信号；数据传输结束后，需要发送一个终止信号；每8bit数据传输结束，都需要一个ACK。起止信号都由Master发出，而ACK则可能由Master或者SLAVE来发出。数据的传输采用大端传输。

开始信号：SCL为高电平，SDA的电平由高跳到低表示开始信号。

终止信号：SCL为高电平，SDA的电平由低跳到高表示终止信号。

![YEQYQO.png](https://s1.ax1x.com/2020/05/06/YEQYQO.png)

写寄存器的标准流程为：

1. Master发起start
2. Master发送IIC addr（7bit）和w操作0（1bit），等待ACK
3. Slave发送ACK
4. Master发送reg addr（8bit），等待ACK
5. Slave发送ACK
6. Master发送data（8bit），即要写入寄存器的数据，等待ACK
7. Slave发送ACK
8. 第6步和第7步可以重复多次，即顺序写多个寄存器
9. Master发起stop

读寄存器的标准流程为：

1. Master发送IIC addr（7bit）和w操作0（1bit），等待ACK
2. Slave发送ACK
3. Master发送reg addr（8bit），等待ACK
4. Slave发送ACK
5. Master发送start
6. Master发送IIC addr（7bit）和r操作1（1bit），等待ACK
7. Slave发送ACK
8. Slave发送data（8bit），即寄存器里的值
9. Master发送ACK
10. 第8步和第9步可以重复多次，即顺序读多个寄存器

### 3.SPI总线

SPI(Serial Peripheral Interface)是一个**串行的同步传输协议**，不同于UART和IIC，没有起始位和结束位而是以时钟沿来同步和传输；不同于采用数据包的形式，数据可以连续不中断地传输。是一种**一对多的传输协议**。4线SPI是全双工的接口，而3线SPI是半双工接口，本篇采用更通用的4线SPI来介绍。

![img](https://img-blog.csdn.net/20181016194949655?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjUwOTM2OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

SPI总线有4根逻辑信号线：

- **SLCLK**:串行时钟（由主机产生）
- **SS/CS(Slave Select/Chip Select)**:片选信号（由主机产生），通常是一个低电平有效信号
- **MOSI (Master Output\to→Slave Input)**:主机向从机的数据传输线
- **MISO (Master Input\leftarrow←Slave Output)**:从机向主机的数据传输线

要开始SPI通信，**主机必须发送时钟信号**，并通过使能CS信号选择从机。片选通常是低电平有效信号。因此，主机必须在该信号上发送逻辑0以选择从机。**SPI是全双工接口，主机和从机可以分别通过MOSI和MISO线路同时发送数据**。在SPI通信期间，数据的发送（串行移出到MOSI/SDO总线上）和接收（采样或读入总线(MISO/SDI)上的数据）同时进行。串行时钟沿同步数据的移位和采样。SPI接口允许灵活选择时钟的上升沿或下降沿来采样和/或移位数据。

**主机除了要设置时钟频率，还要设置与数据传输相关的时钟极性和相位**。大多数厂商都将这两个设置选项命名为**CPOL和CPHA**。

- CPOL：决定串行时钟极性。

  - CPOL=0时钟在空闲时处于低电平，时钟的前沿是上升沿、后沿是下降沿。
  - CPOL=1时钟在空闲时处于高电平，时钟的前沿是下降沿、后沿是上升沿。

- CPHA：决定串行时钟相位。

  - CPHA=0时，发出数据的一边（ the "out" side）在前一时钟周期的后沿改变数据，同时接收数据的一方（ the "in" side ）在当前时钟周期的前沿捕获数据。**注意：在第一个时钟周期，第一位数据必须在前沿到来之前出现在MOSI传输线上。**
  - CPHA=1时，发出数据的一边（ the "out" side）在当前时钟周期的前沿改变数据，同时接收数据的一方（ the "in" side）在同一时钟周期的后沿捕获数据。**注意：在最后一个时钟周期，从机要在片选失效之前保持MISO线上的数据。**

  ![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMwLmNuYmxvZ3MuY29tL2Jsb2cyMDE1LzI2ODE4Mi8yMDE1MDgvMjMxNDE3NDYyMzgyMTk1LmdpZg)

所以根据同步时钟信号的极性和相位不同，可以有四种SPI通讯方式。

**主机verilog程序如下：**

```verilog
`timescale 1ns/1ps

module spi_master
#(
	parameter	CLK_FREQUENCE	= 50_000_000		,	//system clk frequence
				SPI_FREQUENCE	= 5_000_000			,	//spi clk frequence
				DATA_WIDTH		= 8					,	//serial word length
				CPOL			= 0					,	//SPI mode selection (mode 0 default)
				CPHA			= 0					 	//CPOL = clock polarity, CPHA = clock phase
)
(
	input								clk			,	//system clk
	input								rst_n		,	//system reset
	input		[DATA_WIDTH-1:0]		data_in		,	//the data sent by mosi
	input								start		,	//a pluse to start the SPI transmission
	input								miso		,	//spi bus miso input
	output	reg							sclk		,	//spi bus sclk
	output	reg							cs_n		,	//spi bus slave select line
	output								mosi		,	//spi bus mosi output
	output	reg							finish		,	//a pluse to indicate the SPI transmission finish and the data_out valid
	output	reg [DATA_WIDTH-1:0]		data_out	 	//the data received by miso,valid when the finish is high
);

localparam	FREQUENCE_CNT	= CLK_FREQUENCE/SPI_FREQUENCE - 1	,
			SHIFT_WIDTH		= log2(DATA_WIDTH)					,
			CNT_WIDTH		= log2(FREQUENCE_CNT)				;

localparam	IDLE	=	3'b000	,
			LOAD	=	3'b001	,
			SHIFT	=	3'b010	,
			DONE	=	3'b100	;

reg		[2:0]				cstate		;	//FSM current state
reg		[2:0]				nstate		;	//FSM next state
reg							clk_cnt_en	;	//start clk_cnt to generate sclk
reg							sclk_a		;	//sclk register to capture the edge of sclk
reg							sclk_b		;	//sclk register to capture the edge of sclk
wire						sclk_posedge;	//posedge of sclk
wire						sclk_negedge;	//negedge of sclk
wire						shift_en	;	//the signal to enable shift register to generate mosi
wire						sampl_en	;	//the signal to sample the data from miso
reg		[CNT_WIDTH-1:0]		clk_cnt		;	//the counter to generate sclk
reg		[SHIFT_WIDTH-1:0]	shift_cnt	;	//the counter to count the number of shifts
reg		[DATA_WIDTH-1:0]	data_reg	;	//the register to latch the data_in,also the shift register
//the counter to generate the sclk
always @(posedge clk or negedge rst_n) begin
	if (!rst_n) 
		clk_cnt <= 'd0;
	else if (clk_cnt_en) 
		if (clk_cnt == FREQUENCE_CNT) 
			clk_cnt <= 'd0;
		else
			clk_cnt <= clk_cnt + 1'b1;
	else
		clk_cnt <= 'd0;
end
//generate the sclk
always @(posedge clk or negedge rst_n) begin
	if (!rst_n) 
		sclk <= CPOL;
	else if (clk_cnt_en) 
		if (clk_cnt == FREQUENCE_CNT)  	
			sclk <= ~sclk; 
		else 
			sclk <= sclk;
	else
		sclk <= CPOL;
end
//------------------------------------------
//to capture the edge of sclk
always @(posedge clk or negedge rst_n) begin
	if (!rst_n) begin
		sclk_a <= CPOL;
		sclk_b <= CPOL;
	end else if (clk_cnt_en) begin
		sclk_a <= sclk;
		sclk_b <= sclk_a;
	end
end

assign sclk_posedge = ~sclk_b & sclk_a;
assign sclk_negedge = ~sclk_a & sclk_b;
//----------------------------------------
//==============================================
//==============GENERATE BLOCKS=================
generate
	case (CPHA)
		0: assign sampl_en = sclk_posedge;
		1: assign sampl_en = sclk_negedge;
		default: assign sampl_en = sclk_posedge;
	endcase
endgenerate

generate
 	case (CPHA)
		0: assign shift_en = sclk_negedge;
 		1: assign shift_en = sclk_posedge;
		default: assign shift_en = sclk_posedge;
	endcase
endgenerate
//=============================================
//FSM-1
always @(posedge clk or negedge rst_n) begin
	if (!rst_n) 
		cstate <= IDLE;
	else 
		cstate <= nstate;
end
//FSM-2
always @(*) begin
	case (cstate)
		IDLE	: nstate = start ? LOAD : IDLE;
		LOAD	: nstate = SHIFT;
		SHIFT	: nstate = (shift_cnt == DATA_WIDTH) ? DONE : SHIFT;
		DONE	: nstate = IDLE;
		default: nstate = IDLE;
	endcase
end
//FSM-3
always @(posedge clk or negedge rst_n) begin
	if (!rst_n) begin
		clk_cnt_en	<= 1'b0	;
		data_reg	<= 'd0	;
		cs_n		<= 1'b1	;
		shift_cnt	<= 'd0	;
		finish <= 1'b0	;
	end else begin
		case (nstate)
			IDLE	: begin
				clk_cnt_en	<= 1'b0	;
				data_reg	<= 'd0	;
				cs_n		<= 1'b1	;
				shift_cnt	<= 'd0	;
				finish 		<= 1'b0	;
			end
			LOAD	: begin
				clk_cnt_en	<= 1'b1		;
				data_reg	<= data_in	;
				cs_n		<= 1'b0		;
				shift_cnt	<= 'd0		;
				finish 		<= 1'b0		;
			end
			SHIFT	: begin
				if (shift_en) begin
					shift_cnt	<= shift_cnt + 1'b1 ;
					data_reg	<= {data_reg[DATA_WIDTH-2:0],1'b0};
				end else begin
					shift_cnt	<= shift_cnt	;
					data_reg	<= data_reg		;
				end
				clk_cnt_en	<= 1'b1	;
				cs_n		<= 1'b0	;
				finish 		<= 1'b0	;
			end
			DONE	: begin
				clk_cnt_en	<= 1'b0	;
				data_reg	<= 'd0	;
				cs_n		<= 1'b1	;
				data_reg	<= 'd0	;
				finish 		<= 1'b1	;
			end
			default	: begin
				clk_cnt_en	<= 1'b0	;
				data_reg	<= 'd0	;
				cs_n		<= 1'b1	;
				data_reg	<= 'd0	;
				finish 		<= 1'b0	;
			end
		endcase
	end
end
//mosi output MSB first
assign mosi = data_reg[DATA_WIDTH-1];
//sample data from the miso line
always @(posedge clk or negedge rst_n) begin
	if (!rst_n) 
		data_out <= 'd0;
	else if (sampl_en) 
		data_out <= {data_out[DATA_WIDTH-1:0],miso};
	else
		data_out <= data_out;
end
//the function to get the width of data 
function integer log2(input integer v);
  begin
	log2=0;
	while(v>>log2) 
	  log2=log2+1;
  end
endfunction

endmodule
```

**从机verilog代码如下：**

```verilog
`timescale 1ns/1ps

module SPI_Slave
#(
	parameter	CLK_FREQUENCE	= 50_000_000		,	//system clk frequence
				SPI_FREQUENCE	= 5_000_000			,	//spi clk frequence
				DATA_WIDTH		= 8					,	//serial word length
				CPOL			= 1					,	//SPI mode selection (mode 0 default)
				CPHA			= 1					 	//CPOL = clock polarity, CPHA = clock phase
)
(
	input								clk			,	//system clk
	input								rst_n		,	//system reset
	input		[DATA_WIDTH-1:0]		data_in		,	//the data sent by miso
	input								sclk		,	//spi bus sclk
	input								cs_n		,	//spi bus slave select line
	input								mosi		,	//spi bus mosi input
	output								miso		,	//spi bus miso output
	output								data_valid	,	//the data received by mosi valid
	output	reg	[DATA_WIDTH-1:0]		data_out	 	//the data received by mosi,valid when data_valid is high
);

localparam	SFIFT_NUM = log2(DATA_WIDTH);

reg	[DATA_WIDTH-1:0]		data_reg	;	//the register to latch the data_in,also the shift register
reg	[ SFIFT_NUM-1:0]		sampl_num	;	//the counter to count the number of sample
reg							sclk_a		;	//sclk register to capture the edge of sclk
reg							sclk_b		;	//sclk register to capture the edge of sclk
wire						sclk_posedge;	//posedge of sclk
wire						sclk_negedge;	//negedge of sclk
reg							cs_n_a		;	//cs_n register to capture the edge of cs_n
reg							cs_n_b		;	//cs_n register to capture the edge of cs_n
wire						cs_n_negedge;	//negedge of cs_n to latch the data
wire						shift_en	;	//the signal to enable shift register to generate mosi
wire						sampl_en	;	//the signal to sample the data from miso
//------------------------------------------
//to capture the edge of sclk
always @(posedge clk or negedge rst_n) begin
	if (!rst_n) begin
		sclk_a <= CPOL;
		sclk_b <= CPOL;
	end else if (!cs_n) begin
		sclk_a <= sclk;
		sclk_b <= sclk_a;
	end
end

assign sclk_posedge = ~sclk_b & sclk_a;
assign sclk_negedge = ~sclk_a & sclk_b;
//------------------------------------------
//to capture the edge of sclk
always @(posedge clk or negedge rst_n) begin
	if (!rst_n) begin
		cs_n_a	<= 1'b1;
		cs_n_b	<= 1'b1;
	end else begin
		cs_n_a	<= cs_n		;
		cs_n_b	<= cs_n_a	;
	end
end

assign cs_n_negedge = ~cs_n_a & cs_n_b;
//------------------------------------------
//==============================================
//==============GENERATE BLOCKS=================
generate
	case (CPHA)
		0: assign sampl_en = sclk_posedge;
		1: assign sampl_en = sclk_negedge;
		default: assign sampl_en = sclk_posedge;
	endcase
endgenerate

generate
 	case (CPHA)
		0: assign shift_en = sclk_negedge;
 		1: assign shift_en = sclk_posedge;
		default: assign shift_en = sclk_posedge;
	endcase
endgenerate
//==================================================
//the register to latch the data_in
//also the shift register to generate the miso
always @(posedge clk or negedge rst_n) begin
	if (!rst_n) 
		data_reg <= 'd0;
	else if(cs_n_negedge)
		data_reg <= data_in;
	else if (!cs_n & shift_en) 
		data_reg <= {data_reg[DATA_WIDTH-2:0],1'b0};
	else
		data_reg <= data_reg;
end
//miso output MSB first
assign miso = !cs_n ? data_reg[DATA_WIDTH-1] : 1'd0;
//==================================================
//sample data from the mosi line
always @(posedge clk or negedge rst_n) begin
	if (!rst_n) 
		data_out <= 'd0;
	else if (!cs_n & sampl_en) 
		data_out <= {data_out[DATA_WIDTH-2:0],mosi};
	else
		data_out <= data_out;
end
//the counter to count the number of sampled data bit
always @(posedge clk or negedge rst_n) begin
	if (!rst_n) 
		sampl_num <= 'd0;
	else if (cs_n)
		sampl_num <= 'd0;
	else if (!cs_n & sampl_en) 
		if (sampl_num == DATA_WIDTH)
			sampl_num <= 'd1;
		else
			sampl_num <= sampl_num + 1'b1;
	else
		sampl_num <= sampl_num;
end
//the received data valid
assign data_valid = sampl_num == DATA_WIDTH;
//the function to get the width of data 
function integer log2(input integer v);
  begin
	log2=0;
	while(v>>log2) 
	  log2=log2+1;
  end
endfunction

endmodule
```

