---
layout:     post
title:      学习笔记： 硬件接口详解
subtitle:   Learning Notes
date:       2020-04-26
author:     MZ
header-img: img/post-bg-Reading-cyydcx.jpg
catalog: true
tags:
    - Learning Notes

---

# 硬件接口详解

> 记录硬件工程师常用的接口知识，方便深入理解

## 一、串行

### 1. UART

通用异步收发传输器（Universal Asynchronous Receiver/Transmitter)，通常称作UART。

UART是个大家族，包括了RS232、RS499、RS423、RS422和RS485等接口标准规范和总线标准规范。它们的主要区别在于其各自的电平范围不相同。

嵌入式设备中常常使用到的是TTL、TTL转RS232的这种方式。常用的就三根引线：发送线TX、接收线RX、电平参考地线GND。

UART作为异步串口通信协议的一种，工作原理是将传输数据的每个字符一位一位地传输。其中，各位的意义如下：

- **起始位：**先发出一个逻辑“0”的信号，表示传输字符的开始。

- **数据位：**紧接着起始位之后。数据位的个数可以是4、5、6、7、8等，构成一个字符。通常采用ASCII码。

- **奇偶校验位：**数据位加上这一位后(数据和校验位)，使得“1”的位数应为偶数（偶校验）或奇校验（奇校验），以此来校验资料的传送正确性。**工程上利用归约异或的结果作为偶校验，奇校验则取反。**

- **停止位：**它是一个字符数据的结束标志。可以是1位、1.5位、2位的高电平。
- **空闲位：**处于逻辑“1”的状态，表示当前线路上没有资料传输。

![JcXaxs.png](https://s1.ax1x.com/2020/04/26/JcXaxs.png)



数据传输速率用波特率表示，即每秒传送的二进制位数。例如数据传输速率为120字符/秒，而每一个字符为10位（1个起始位，7个数据位，1个校验位，1个结束位），则波特率为10*120=1200

**UART抛开了clock信号，通过采样的方式进行识别，所以在数据传输的双方需要定义统一波特率，以便正确的传输数据。**

**FPGA程序设计**

对于FPGA设计，主要有三个模块组成：**波特率发生模块、发送模块，接收模块**组成。

1. **波特率发生模块**

   设计的UART的接收和发送按照相同的波特率进行，FPGA 主频如果为50M，则时钟周期就是20ns。若数据发送速率为9600bps，则一位数据需要的时间为1000000000/9600=104167ns，则FPGA 传送一位需要翻转104167/20=5208个周期才可传送一位，所以程序中需计数5208才可满足9600bps。

   简单一点就是**时钟频率除以波特率**就是需要的计数。

   参考代码：（转载自https://github.com/halftop/Interface-Protocol-in-Verilog/tree/master/general_uart 感谢）

   ```verilog
   `timescale 1ns / 1ps
   module tx_clk_gen
   #(
       parameter   CLK_FREQUENCE   = 50_000_000,       //hz
                   BAUD_RATE       = 9600              //9600、19200 、38400 、57600 、115200、230400、460800、921600
   )
   (
       input                   clk         ,   //system_clk
       input                   rst_n       ,   //system_reset
       input                   tx_done     ,   //once_tx_done
       input                   tx_start    ,   //once_tx_start
       output  reg             bps_clk         //baud_rate_clk
   );
    
   localparam  BPS_CNT =   CLK_FREQUENCE/BAUD_RATE-1,
               BPS_WD  =   log2(BPS_CNT);
    
   reg [BPS_WD-1:0] count;
   reg c_state;
   reg n_state;
   //FSM-1         1'b0:IDLE   1'b1:send_data
   always @(posedge clk or negedge rst_n) begin
       if (!rst_n)
           c_state <= 1'b0;
       else
           c_state <= n_state;
   end
   //FSM-2
   always @(*) begin
       case (c_state)
           1'b0: n_state = tx_start ? 1'b1 : 1'b0;
           1'b1: n_state = tx_done ? 1'b0 : 1'b1;
           default: n_state = 1'b0;
       endcase
   end
   //FSM-3 FSM's output(count_en) is equal to c_state
    
   //baud_rate_clk_counter
   always @(posedge clk or negedge rst_n) begin
       if (!rst_n)
           count <= {BPS_WD{1'b0}};
       else if (!c_state)
           count <= {BPS_WD{1'b0}};
       else begin
           if (count == BPS_CNT) 
               count <= {BPS_WD{1'b0}};
           else
               count <= count + 1'b1;
       end
   end
   //baud_rate_clk_output
   always @(posedge clk or negedge rst_n) begin
       if (!rst_n)
           bps_clk <= 1'b0;
       else if (count == 'd1)
           bps_clk <= 1'b1;
       else
           bps_clk <= 1'b0;
   end
   //get_the_width_of_
   function integer log2(input integer v);
     begin
       log2=0;
       while(v>>log2) 
         log2=log2+1;
     end
   endfunction
    
   endmodule
   ```

   **重点关注以上代码的log2函数。**

2. **数据帧发送模块**：

   支持通过参数设定波特率、奇偶检验位及数据位宽。采用状态机和移位寄存器实现。当有校验位时则发送检验位；若没有校验位则直接发送停止位（发送两次停止位），如下所示。

   ```verilog
   `timescale 1ns / 1ps
   module uart_frame_tx
   #(
       parameter   CLK_FREQUENCE   = 50_000_000,       //hz
                   BAUD_RATE       = 9600      ,       //9600、19200 、38400 、57600 、115200、230400、460800、921600
                   PARITY          = "NONE"    ,       //"NONE","EVEN","ODD"
                   FRAME_WD        = 8                 //if PARITY="NONE",it can be 5~9;else 5~8
   )
   (
       input                       clk         ,   //system_clk
       input                       rst_n       ,   //system_reset
       input                       frame_en    ,   //once_tx_start
       input       [FRAME_WD-1:0]  data_frame  ,   //data_to_tx
       output  reg                 tx_done     ,   //once_tx_done
       output  reg                 uart_tx         //uart_tx_data
   );
    
   wire    bps_clk;
    
   tx_clk_gen
   #(
       .CLK_FREQUENCE  (CLK_FREQUENCE),        //hz
       .BAUD_RATE      (BAUD_RATE  )           //9600、19200 、38400 、57600 、115200、230400、460800、921600
   )
   tx_clk_gen_inst
   (
       .clk            ( clk        ),     //system_clk
       .rst_n          ( rst_n      ),     //system_reset
       .tx_done        ( tx_done    ),     //once_tx_done
       .tx_start       ( frame_en   ),     //once_tx_start
       .bps_clk        ( bps_clk    )      //baud_rate_clk
   );
    
   localparam  IDLE        =   6'b00_0000  ,
               READY       =   6'b00_0001  ,
               START_BIT   =   6'b00_0010  ,
               SHIFT_PRO   =   6'b00_0100  ,
               PARITY_BIT  =   6'b00_1000  ,
               STOP_BIT    =   6'b01_0000  ,
               DONE        =   6'b10_0000  ;
    
   wire    [1:0]   verify_mode;
   generate
       if (PARITY == "ODD")
           assign verify_mode = 2'b01;
       else if (PARITY == "EVEN")
           assign verify_mode = 2'b10;
       else
           assign verify_mode = 2'b00;
   endgenerate
    
   reg     [FRAME_WD-1:0]  data_reg    ;
   reg     [log2(FRAME_WD-1)-1:0] cnt  ;
   reg                     parity_even ;
   reg     [5:0]           cstate      ;
   reg     [5:0]           nstate      ;
    
   always @(posedge clk or negedge rst_n) begin
       if (!rst_n)
           cnt <= 'd0;
       else if (cstate == SHIFT_PRO & bps_clk == 1'b1) 
           if (cnt == FRAME_WD-1)
               cnt <= 'd0;
           else
               cnt <= cnt + 1'b1;
       else
           cnt <= cnt;
   end
   //FSM-1
   always @(posedge clk or negedge rst_n) begin
       if (!rst_n)
           cstate <= IDLE;
       else
           cstate <= nstate;
   end
   //FSM-2
   always @(*) begin
       case (cstate)
           IDLE        : nstate = frame_en ? READY : IDLE  ;
           READY       : nstate = (bps_clk == 1'b1) ? START_BIT : READY;
           START_BIT   : nstate = (bps_clk == 1'b1) ? SHIFT_PRO : START_BIT;
           SHIFT_PRO   : nstate = (cnt == FRAME_WD-1 & bps_clk == 1'b1) ? PARITY_BIT : SHIFT_PRO;
           PARITY_BIT  : nstate = (bps_clk == 1'b1) ? STOP_BIT : PARITY_BIT;
           STOP_BIT    : nstate = (bps_clk == 1'b1) ? DONE : STOP_BIT;
           DONE        : nstate = IDLE;
           default     : nstate = IDLE;
       endcase
   end
   //FSM-3
   always @(posedge clk or negedge rst_n) begin
       if (!rst_n) begin
           data_reg <= 'd0;
           uart_tx <= 1'b1;
           tx_done <= 1'b0;
           parity_even <= 1'b0;
       end else begin
           case (nstate)
               IDLE        : begin
                               data_reg <= 'd0;
                               tx_done <= 1'b0;
                               uart_tx <= 1'b1;
                           end
               READY       : begin
                               data_reg <= 'd0;
                               tx_done <= 1'b0;
                               uart_tx <= 1'b1;
                           end
               START_BIT   : begin
                               data_reg <= data_frame;
                               parity_even <= ^data_frame;     //生成偶校验位
                               uart_tx <= 1'b0;
                               tx_done <= 1'b0;
                           end
               SHIFT_PRO   : begin
                               if(bps_clk == 1'b1) begin
                                   data_reg <= {1'b0,data_reg[FRAME_WD-1:1]};
                                   uart_tx <= data_reg[0];
                               end else begin
                                   data_reg <= data_reg;
                                   uart_tx <= uart_tx;
                               end
                               tx_done <= 1'b0;
                           end
               PARITY_BIT  : begin
                               data_reg <= data_reg;
                               tx_done <= 1'b0;
                               case (verify_mode)
                                   2'b00: uart_tx <= 1'b1;     //若无校验多发一位STOP_BIT
                                   2'b01: uart_tx <= ~parity_even;
                                   2'b10: uart_tx <= parity_even;
                                   default: uart_tx <= 1'b1;
                               endcase
                           end
               STOP_BIT    : uart_tx <= 1'b1;
               DONE        : tx_done <= 1'b1;
               default     :  begin
                               data_reg <= 'd0;
                               uart_tx <= 1'b1;
                               tx_done <= 1'b0;
                               parity_even <= 1'b0;
                           end
           endcase
       end
   end
    
   function integer log2(input integer v);
     begin
       log2=0;
       while(v>>log2) 
         log2=log2+1;
     end
   endfunction
    
   endmodule
   ```

   数据接收模块设计如下：

   ```verilog
   module uart_frame_rx
   #(
       parameter   CLK_FREQUENCE   = 50_000_000,       //hz
                   BAUD_RATE       = 9600      ,       //9600、19200 、38400 、57600 、115200、230400、460800、921600
                   PARITY          = "NONE"    ,       //"NONE","EVEN","ODD"
                   FRAME_WD        = 8                 //if PARITY="NONE",it can be 5~9;else 5~8
   )
   (
       input                       clk         ,       //sys_clk
       input                       rst_n       ,       
       input                       uart_rx     ,       
       output  reg [FRAME_WD-1:0]  rx_frame    ,       //frame_received,when rx_done = 1 it's valid
       output  reg                 rx_done     ,       //once_rx_done
       output  reg                 frame_error         //when the PARITY is enable if frame_error = 1,the frame received is wrong
   );
    
   wire            sample_clk      ;
   wire            frame_en        ;       //once_rx_start
   reg             cnt_en          ;       //sample_clk_cnt enable
   reg     [3:0]   sample_clk_cnt  ;       
   reg     [log2(FRAME_WD+1)-1:0]      sample_bit_cnt  ;
   wire            baud_rate_clk   ;
    
   localparam  IDLE        =   5'b0_0000,
               START_BIT   =   5'b0_0001,
               DATA_FRAME  =   5'b0_0010,
               PARITY_BIT  =   5'b0_0100,
               STOP_BIT    =   5'b0_1000,
               DONE        =   5'b1_0000;
    
   reg [4:0]   cstate;
   reg [4:0]   nstate;
   //
   wire    [1:0]   verify_mode;
   generate
       if (PARITY == "ODD")
           assign verify_mode = 2'b01;
       else if (PARITY == "EVEN")
           assign verify_mode = 2'b10;
       else
           assign verify_mode = 2'b00;
   endgenerate
   //detect the start condition--the negedge of uart_rx
   reg     uart_rx0,uart_rx1,uart_rx2,uart_rx3;
    
   always @(posedge clk or negedge rst_n) begin
       if (!rst_n) begin
           uart_rx0 <= 1'b0;
           uart_rx1 <= 1'b0;
           uart_rx2 <= 1'b0;
           uart_rx3 <= 1'b0;
       end else begin
           uart_rx0 <= uart_rx ;
           uart_rx1 <= uart_rx0;
           uart_rx2 <= uart_rx1;
           uart_rx3 <= uart_rx2;
       end
   end
   //negedge of uart_rx-----start_bit
   assign frame_en = uart_rx3 & uart_rx2 & ~uart_rx1 & ~uart_rx0;
    
   always @(posedge clk or negedge rst_n) begin
       if (!rst_n) 
           cnt_en <= 1'b0;
       else if (frame_en) 
           cnt_en <= 1'b1;
       else if (rx_done) 
           cnt_en <= 1'b0;
       else
           cnt_en <= cnt_en;
   end
    
   assign baud_rate_clk = sample_clk & sample_clk_cnt == 4'd8;
    
   always @(posedge clk or negedge rst_n) begin
       if (!rst_n) 
           sample_clk_cnt <= 4'd0;
       else if (cnt_en) begin
           if (baud_rate_clk) 
               sample_clk_cnt <= 4'd0;
           else if (sample_clk)
               sample_clk_cnt <= sample_clk_cnt + 1'b1;
           else
               sample_clk_cnt <= sample_clk_cnt;
       end else 
           sample_clk_cnt <= 4'd0;
   end
   //the start_bit is the first one (0),then the LSB of the data_frame is the second(1) ......
   always @(posedge clk or negedge rst_n) begin
       if (!rst_n) 
           sample_bit_cnt <= 'd0;
       else if (cstate == IDLE)
           sample_bit_cnt <= 'd0;
       else if (baud_rate_clk)
           sample_bit_cnt <= sample_bit_cnt + 1'b1;
       else
           sample_bit_cnt <= sample_bit_cnt;
   end
   //read the readme
   reg     [1:0]   sample_result   ;
   always @(posedge clk or negedge rst_n) begin
       if (!rst_n) 
           sample_result <= 1'b0;
       else if (sample_clk) begin
           case (sample_clk_cnt)
               4'd0:sample_result <= 2'd0;
               4'd3,4'd4,4'd5: sample_result <= sample_result + uart_rx;
               default: sample_result <= sample_result;
           endcase
       end
   end
   //FSM-1
   always @(posedge clk or negedge rst_n) begin
       if (!rst_n) 
           cstate <= IDLE;
       else 
           cstate <= nstate;
   end
   //FSM-2
   always @(*) begin
       case (cstate)
           IDLE        : nstate = frame_en ? START_BIT : IDLE ;
           START_BIT   : nstate = (baud_rate_clk & sample_result[1] == 1'b0) ? DATA_FRAME : START_BIT ;
           DATA_FRAME  : begin
                           case (verify_mode[1]^verify_mode[0])
                               1'b1: nstate = (sample_bit_cnt == FRAME_WD & baud_rate_clk) ? PARITY_BIT : DATA_FRAME ;     //parity is enable
                               1'b0: nstate = (sample_bit_cnt == FRAME_WD & baud_rate_clk) ? STOP_BIT : DATA_FRAME ;       //parity is disable
                               default: nstate = (sample_bit_cnt == FRAME_WD & baud_rate_clk) ? STOP_BIT : DATA_FRAME ;    //defasult is disable
                           endcase
                       end
           PARITY_BIT  : nstate = baud_rate_clk ? STOP_BIT : PARITY_BIT ;
           STOP_BIT    : nstate = (baud_rate_clk & sample_result[1] == 1'b1) ? DONE : STOP_BIT ;
           DONE        : nstate = IDLE;
           default: nstate = IDLE;
       endcase
   end
   //FSM-3
   always @(posedge clk or negedge rst_n) begin
       if (!rst_n) begin
           rx_frame    <= 'd0;
           rx_done     <= 1'b0;
           frame_error <= 1'b0;
       end else begin
           case (nstate)
               IDLE        : begin
                               rx_frame    <= 'd0;
                               rx_done     <= 1'b0;
                               frame_error <= 1'b0;
                           end 
               START_BIT   : begin
                               rx_frame    <= 'd0;
                               rx_done     <= 1'b0;
                               frame_error <= 1'b0;
                           end 
               DATA_FRAME  : begin
                               if (sample_clk & sample_clk_cnt == 4'd6) 
                                   rx_frame <= {sample_result[1],rx_frame[FRAME_WD-1:1]};
                               else
                                   rx_frame    <= rx_frame;
                               rx_done     <= 1'b0;
                               frame_error <= 1'b0;
                           end 
               PARITY_BIT  : begin
                               rx_frame    <= rx_frame;
                               rx_done     <= 1'b0;
                               if (sample_clk_cnt == 4'd8)
                               frame_error <= ^rx_frame ^ sample_result[1];
                               else
                               frame_error <= frame_error;
                           end 
               STOP_BIT    : begin
                               rx_frame    <= rx_frame;
                               rx_done     <= 1'b0;
                               frame_error <= frame_error;
                           end 
               DONE        : begin
                               frame_error <= frame_error;
                               rx_done     <= 1'b1;
                               rx_frame    <= rx_frame;
                           end 
               default: begin
                               rx_frame    <= rx_frame;
                               rx_done     <= 1'b0;
                               frame_error <= frame_error;
                           end 
           endcase
       end
   end
    
   rx_clk_gen
   #(
       .CLK_FREQUENCE  (CLK_FREQUENCE  ),  //hz
       .BAUD_RATE      (BAUD_RATE      )   //9600、19200 、38400 、57600 、115200、230400、460800、921600
   )
   rx_clk_gen_inst
   (
       .clk            ( clk        )  ,
       .rst_n          ( rst_n      )  ,
       .rx_start       ( frame_en   )  ,
       .rx_done        ( rx_done    )  ,
       .sample_clk     ( sample_clk )  
   );  
    
   function integer log2(input integer v);
     begin
       log2=0;
       while(v>>log2) 
         log2=log2+1;
     end
   endfunction
   endmodule
   ```

   根据uart协议，数据传输线空闲时位高电平，数据传输以一位低电平的起始位开始，因此**准确检测起始位是数据成功传输的关键**。由于接受端和发送端是异步的，**需要专门的边沿检测电路来捕捉下降沿**。这里采用4个移位寄存器，连续采集4个时钟上升沿时的数据，通过对比前两个时刻和后两个时刻的数据线的状态来得到数据线准确的下降沿，获得准确的开始接收条件。

   在简单的串口接收中，我们通常选取一位数据的中间时刻进行采样，因为此时数据最稳定，但是在工业环境中，存在着各种干扰，在干扰存在的情况下，**如果采用传统的中间时刻采样一次的方式，采样结果就有可能受到干扰而出错**。为了滤除这种干扰，这里采用多次采样求概率的方式。如下图，将一位数据平均分成9个时间段，对位于中间的三个时间段进行采样。然后对三个采样结果进行统计判断，**如果某种电平状态在三次采样结果中占到了两次及以上，则可以判定此电平状态即为正确的数据电平。**例如4、5、6时刻采样结果分别为1、1、0，那么就取此位解码结果为1，否则，若三次采样结果为0、1、0，则解码结果就为0。即3次采样为a,b,c，则结果为`a&b | b&c |a&c`，显而易见此结果是**全加器的进位**。

   ![数据采样示例](https://i.loli.net/2019/06/11/5cffa2289f6cb31791.png)

   **所以采样时钟应该是波特率时钟的9倍！**

   ```verilog
   `timescale 1ns / 1ps
    
   module rx_clk_gen
   #(
       parameter   CLK_FREQUENCE   = 50_000_000,   //hz
                   BAUD_RATE       = 9600          //9600、19200 、38400 、57600 、115200、230400、460800、921600
   )
   (
       input                   clk         ,
       input                   rst_n       ,
       input                   rx_start    ,
       input                   rx_done     ,
       output  reg             sample_clk   
   );
    
   localparam  SMP_CLK_CNT =   CLK_FREQUENCE/BAUD_RATE/9 - 1,
               CNT_WIDTH   =   log2(SMP_CLK_CNT)            ;
    
   reg     [CNT_WIDTH-1:0] clk_count   ;
   reg     cstate;
   reg     nstate;
   //FSM-1 1'b0:IDLE 1'b1:RECEIVE
   always @(posedge clk or negedge rst_n) begin
       if (!rst_n) begin
           cstate <= 1'b0;
       end else begin
           cstate <= nstate;
       end
   end
   //FSM-2
   always @(*) begin
       case (cstate)
           1'b0: nstate = rx_start ? 1'b1 : 1'b0;
           1'b1: nstate = rx_done ? 1'b0 : 1'b1 ;
           default: nstate = 1'b0;
       endcase
   end
   //FSM-3 FSM's output(clk_count_en) is equal to cstate
    
   //sample_clk_counter
   always @(posedge clk or negedge rst_n) begin
       if (!rst_n) 
           clk_count <= 'd0;
       else if (!cstate) 
           clk_count <= 'd0;
       else if (clk_count == SMP_CLK_CNT)
           clk_count <= 'd0;
       else
           clk_count <= clk_count + 1'b1;
   end
   //generate sample_clk = 9xBAUD_RATE
   always @(posedge clk or negedge rst_n) begin
       if (!rst_n) 
           sample_clk <= 1'b0;
       else if (clk_count == 1'b1) 
           sample_clk <= 1'b1;
       else 
           sample_clk <= 1'b0;
   end
   //get the width of sample_clk_counter
   function integer log2(input integer v);
     begin
       log2=0;
       while(v>>log2) 
         log2=log2+1;
     end
   endfunction
    
   endmodule
   ```

   UART模块内容多参考了halftop大神的代码，思考全面代码整洁，感谢。

### 2. IIC总线

IIC（Inter-Integrated Circuit）。一种**串行数据总线，只有两根信号线**，一根是双向的数据线SDA，另一根是时钟线SCL。两条线可以挂多个设备。IIC设备（绝大多数）具有固化的地址，只有在两条线上传输的值等于IIC设备的固化地址时，其才会作出响应。通常我们为了方便把IIC设备分为主设备和从设备，基本上谁**控制时钟线（即控制SCL的电平高低变换）谁就是主设备。**

![dzLBjO.png](https://s1.ax1x.com/2020/09/02/dzLBjO.png)

数据传输开始时，需要发送一个起始信号；数据传输结束后，需要发送一个终止信号；每8bit数据传输结束，都需要一个ACK。起止信号都由Master发出，而ACK则可能由Master或者SLAVE来发出。数据的传输采用大端传输。

**空闲状态**：两根总线均为高电平，此时各个器件的输出级场效应管均处在截止状态，即释放总线，由两条信号线各自的上拉电阻把电平拉高。

**开始信号**：SCL为高电平，SDA的电平由高跳到低表示开始信号。

**有效位传输**：当采集IIC上的数据时，其时钟线SCL必须是高电平且SDA的数据必须保持稳定不变——将SDA的电平与SCL的高电平进行“与”操作后，以便确定SDA上是1还是0；在SCL为低电平的时候，SDA上的数据可以进行跳变。

![wSSszR.png](https://s1.ax1x.com/2020/09/02/wSSszR.png)

**终止信号**：SCL为高电平，SDA的电平由低跳到高表示终止信号。

<img src="https://s1.ax1x.com/2020/05/06/YEQYQO.png" alt="YEQYQO.png" style="zoom:67%;" />

**应答信号与非应答信号：**I2C 总线上的所有数据都是以 8 位字节传送的，发送器(主机)每发送一个字节，就在第9个时钟脉冲期间释放数据线，由接收器(从机)反馈一个应答信号。应答信号为低电平时，规定为有效应答位(ACK简称应答位)，表示接收器已经成功地接收了该字节；应答信号为高电平时，规定为非应答位(NACK)，一般表示接收器接收该字节没有成功。对于反馈有效应答位 ACK 的要求是，接收器在第 9 个时钟脉冲之前的低电平期间将 SDA 线拉低，并且确保在该时钟的高电平期间为稳定的低电平。

对非应答位(NACK)还要特别说明的是，还有以下四种情况IIC通信过程中会产生非应答位：

1. 接收器(从机)**正在处理某些实时的操作**无法与主机实现IIC通信的时候，接收器(从机)会给主机反馈一个非应答位(NACK)
2. 主机发送数据的过程中，**从机无法解析发送的数据**，接收器(从机)也会给主机反馈一个非应答位(NACK)
3. 主机发送数据的过程中，**从机无法再继续接收数据**，接收器(从机)也会给主机反馈一个非应答位(NACK)
4. 主机从从机中读取数据的过程中，**主机不想再接收数据**，主机会给从机反馈一个非应答位(NACK)，注意，这种情况是主机给从机反馈一个非应答位(NACK)

关于有效应答位的图示在上一传输0xaa的图中可以清楚的看到，关于非应答位的图示见下图

![wSpulR.png](https://s1.ax1x.com/2020/09/02/wSpulR.png)

**写寄存器的标准流程为：**

1. Master发起start
2. Master发送IIC addr（7bit）和w操作0（1bit），马上释放SDA信号线，等待ACK
3. Slave发送ACK（1bit的0）
4. Master发送reg addr（8bit），马上释放SDA信号线，等待ACK
5. Slave发送ACK（1bit的0）
6. Master发送data（8bit），即要写入寄存器的数据，等待ACK
7. Slave发送ACK
8. 第6步和第7步可以重复多次，即顺序写多个寄存器
9. Master发起stop

![wSHpPx.png](https://s1.ax1x.com/2020/09/02/wSHpPx.png)

**读寄存器的标准流程为：**

1. Master发起start
2. Master发送IIC addr（7bit）和w操作0（1bit），等待ACK
3. Slave发送ACK（1bit的0）
4. Master发送reg addr（8bit），等待ACK
5. Slave发送ACK（1bit的0）
6. Master发送start（又发一次）
7. Master发送IIC addr（7bit）和r操作1（1bit），等待ACK
8. Slave发送ACK（1bit的0）
9. Slave发送data（8bit），即寄存器里的值
10. Master发送ACK
11. 第8步和第9步可以重复多次，即顺序读多个寄存器
12. Master发送非应答信号（1bit的1）

![wSHVZd.png](https://s1.ax1x.com/2020/09/02/wSHVZd.png)

**设计代码时的关键点：**

1. 由于IIC时序要求数据线SDA在串行时钟线的高电平保持不变，在串行时钟线的低电平才能变化，所以代码里面必须在**串行时钟线低电平的正中间产生一个标志位**，写代码的时候在这个标志位处改变SDA的值，这样就可以保证SDA在SCL的高电平期间保持稳定了。同理，由于IIC从机在接收到主机(FPGA)发送的有效数据以后会在SCL高电平期间产生一个有效应答信号0，所以为了保证采到的应答信号准确，必须在SCL高电平期间的正中间判断应答信号是否满足条件(0为有效应答，1为无效应答)，**因此代码里面还必须在串行时钟线高电平的正中间产生一个标志位**，在这个标志下接收应答位并进行校验。这部分的代码通过一个计数器就很容易实现，代码如下：

  ```verilog
  parameter   C_DIV_SELECT        =   10'd500 ; // 分频系数选择

  parameter   C_DIV_SELECT0       =   (C_DIV_SELECT >> 2)  -  1           , // 用来产生IIC总线SCL低电平最中间的标志位
              C_DIV_SELECT1       =   (C_DIV_SELECT >> 1)  -  1           ,
              C_DIV_SELECT2       =   (C_DIV_SELECT0 + C_DIV_SELECT1) + 1 , // 用来产生IIC总线SCL高电平最中间的标志位
              C_DIV_SELECT3       =   (C_DIV_SELECT >> 1)  +  1           ; // 用来产生IIC总线SCL下降沿标志位
  always @(posedge I_clk or negedge I_rst_n)
  begin
      if(!I_rst_n)
          R_scl_cnt   <=  10'd0 ; 
      else if(R_scl_en)   
          begin
              if(R_scl_cnt == C_DIV_SELECT - 1'b1)
                  R_scl_cnt <= 10'd0 ;
              else
                  R_scl_cnt <= R_scl_cnt + 1'b1 ;     
          end
      else
          R_scl_cnt   <= 10'd0 ;
  end

  assign O_scl          = (R_scl_cnt <= C_DIV_SELECT1) ? 1'b1 : 1'b0 ; // 产生串行时钟信号O_scl
  assign W_scl_low_mid  = (R_scl_cnt == C_DIV_SELECT2) ? 1'b1 : 1'b0 ; // 产生scl低电平正中间标志位
  assign W_scl_high_mid = (R_scl_cnt == C_DIV_SELECT0) ? 1'b1 : 1'b0 ; // 产生scl高电平正中间标志位
  ```

2. **有了SCL信号低电平正中间标志位和高电平正中间标志位以后最好还产生一个下降沿的标志位。**原因是在发送第一个8-bit数据以后，处理这个8-bit数据应答位的位置在SCL信号高电平的正中间，由于要复用发送8-bit数据的那个状态，所以必须在第二次进入发送8-bit数据的状态时必须提前把数据再次加载好，因此可以在这个下降沿的标志来加载第二次要发送的数据，然后在SCL下降沿的正中间把8-bit数据发出去。这里必须结合代码来理解，这里可以暂时有个印象。

3. IIC总线的SDA数据线是一个双向IO口。

   ```verilog
   module Test_inout(
   input   I_clk,
   input   I_rst_n,
   inout   IO_data);
     
   reg     R_data_out  ;
   wire    I_data_in   ;
   assign  IO_data = Control ? R_data_out : 1'bz ;
   assign  I_data_in = IO_data ;
   ```

4. 写模块状态机可以有以下几种，可以多次复用

   - 状态0：空闲状态，用来初始化各个寄存器的值
   - 状态1：加载IIC设备的物理地址
   - 状态2：加载IIC设备的字地址
   - 状态3：加载要发送的数据
   - 状态4：发送起始信号
   - 状态5：发送一个字节，从高位开始发送
   - 状态6：接收应答状态的应答位
   - 状态7：校验应答位
   - 状态8：发送停止信号
   - 状态9：IIC写操作结束

5. 读模块状态机可以有以下几种，可以多次复用

   - 状态0：空闲状态，用来初始化各个寄存器的值
   - 状态1：加载IIC设备的物理地址
   - 状态2：加载IIC设备的字地址
   - 状态3：发送第一个起始信号(读过程要求发送两次起始信号)
   - 状态4：发送一个字节数据，从高位开始发送
   - 状态5：接收应答状态的应答位
   - 状态6：校验应答位
   - 状态7：发送第二个起始信号(读过程要求发送两次起始信号
   - 状态8：再次加载IIC设备的物理地址，但这次物理地址最后一位应该为1，表示读操作
   - 状态9：接收一个字节数据，从高位开始接收
   - 状态10：主机发送一个非应答信号1给从机
   - 状态11：等确定从机收到这个非应答信号1以后，初始化SDA的值为0，准备产生停止信号
   - 状态12：发送停止信号
   - 状态13：读操作结束

6. 读完一个字节数据以后，一定要记住是主机(FPGA)给从机(24LC04)发送一个非应答信号1

设计细节参照博客：https://www.cnblogs.com/liujinggang/p/9656358.html，感谢。

### 3. SPI总线

SPI(Serial Peripheral Interface)是一个**串行的同步传输协议**，数据传输时**高位在前，低位在后**。不同于UART和IIC，没有起始位和结束位而是以时钟沿来同步和传输；不同于采用数据包的形式，数据可以连续不中断地传输。是一种**一对多的传输协议**。4线SPI是全双工的接口，而3线SPI是半双工接口，本篇采用更通用的4线SPI来介绍。

![dzqPL4.png](https://s1.ax1x.com/2020/09/02/dzqPL4.png)

SPI总线有4根逻辑信号线：

- **SLCLK**:串行时钟（由主机产生）
- **SS/CS(Slave Select/Chip Select)**:片选信号（由主机产生），通常是一个低电平有效信号
- **MOSI (Master Output\to→Slave Input)**:主机向从机的数据传输线
- **MISO (Master Input\leftarrow←Slave Output)**:从机向主机的数据传输线

要开始SPI通信，**主机必须发送时钟信号**，并通过使能CS信号选择从机。片选通常是低电平有效信号。因此，主机必须在该信号上发送逻辑0以选择从机。**SPI是全双工接口，主机和从机可以分别通过MOSI和MISO线路同时发送数据**。在SPI通信期间，数据的发送（串行移出到MOSI/SDO总线上）和接收（采样或读入总线(MISO/SDI)上的数据）同时进行。串行时钟沿同步数据的移位和采样。SPI接口允许灵活选择时钟的上升沿或下降沿来采样和/或移位数据。

SPI协议规定一个SPI设备不能在数据通信过程中仅仅充当一个发送者（Transmitter）或者接受者（Receiver）。在片选信号CS为0的情况下，每个clock周期内，SPI设备都会发送并接收1 bit数据，相当于有1 bit数据被交换了。数据传输高位在前，低位在后（MSB first）。SPI主从结构内部数据传输示意图如下图所示

![dzbXon.png](https://s1.ax1x.com/2020/09/02/dzbXon.png)

**主机除了要设置时钟频率，还要设置与数据传输相关的时钟极性和相位**。大多数厂商都将这两个设置选项命名为**CPOL和CPHA**。

- CPOL：决定串行时钟极性。

  - CPOL=0时钟在空闲时处于低电平，时钟的前沿是上升沿、后沿是下降沿。
  - CPOL=1时钟在空闲时处于高电平，时钟的前沿是下降沿、后沿是上升沿。

- CPHA：决定串行时钟相位。

  - CPHA=0时，发出数据的一边（ the "out" side）在前一时钟周期的后沿改变数据，同时接收数据的一方（ the "in" side ）在当前时钟周期的前沿捕获数据。**注意：在第一个时钟周期，第一位数据必须在前沿到来之前出现在MOSI传输线上。**
  - CPHA=1时，发出数据的一边（ the "out" side）在当前时钟周期的前沿改变数据，同时接收数据的一方（ the "in" side）在同一时钟周期的后沿捕获数据。**注意：在最后一个时钟周期，从机要在片选失效之前保持MISO线上的数据。**

  ![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMwLmNuYmxvZ3MuY29tL2Jsb2cyMDE1LzI2ODE4Mi8yMDE1MDgvMjMxNDE3NDYyMzgyMTk1LmdpZg)

所以根据同步时钟信号的极性和相位不同，可以有四种SPI通讯方式。

**主机verilog程序如下：**

```verilog
`timescale 1ns/1ps

module spi_master
#(
	parameter	CLK_FREQUENCE	= 50_000_000,	//system clk frequence
				SPI_FREQUENCE	= 5_000_000,	//spi clk frequence
				DATA_WIDTH = 8,	//serial word length
				CPOL = 0,	//SPI mode selection (mode 0 default)
				CPHA = 0//CPOL = clock polarity, CPHA = clock phase
)
(
	input								clk			,	//system clk
	input								rst_n		,	//system reset
	input		[DATA_WIDTH-1:0]		data_in		,	//the data sent by mosi
	input								start		,	//a pluse to start the SPI transmission
	input								miso		,	//spi bus miso input
	output	reg							sclk		,	//spi bus sclk
	output	reg							cs_n		,	//spi bus slave select line
	output								mosi		,	//spi bus mosi output
	output	reg							finish		,	//a pluse to indicate the SPI transmission finish and the data_out valid
	output	reg [DATA_WIDTH-1:0]		data_out	 	//the data received by miso,valid when the finish is high
);

localparam	FREQUENCE_CNT	= CLK_FREQUENCE/SPI_FREQUENCE - 1	,
			SHIFT_WIDTH		= log2(DATA_WIDTH),
			CNT_WIDTH		= log2(FREQUENCE_CNT);

localparam	IDLE	=	3'b000	,
			LOAD	=	3'b001	,
			SHIFT	=	3'b010	,
			DONE	=	3'b100	;

reg		[2:0]				cstate		;	//FSM current state
reg		[2:0]				nstate		;	//FSM next state
reg							clk_cnt_en	;	//start clk_cnt to generate sclk
reg							sclk_a		;	//sclk register to capture the edge of sclk
reg							sclk_b		;	//sclk register to capture the edge of sclk
wire						sclk_posedge;	//posedge of sclk
wire						sclk_negedge;	//negedge of sclk
wire						shift_en	;	//the signal to enable shift register to generate mosi
wire						sampl_en	;	//the signal to sample the data from miso
reg		[CNT_WIDTH-1:0]		clk_cnt		;	//the counter to generate sclk
reg		[SHIFT_WIDTH-1:0]	shift_cnt	;	//the counter to count the number of shifts
reg		[DATA_WIDTH-1:0]	data_reg	;	//the register to latch the data_in,also the shift register
//the counter to generate the sclk
always @(posedge clk or negedge rst_n) begin
	if (!rst_n) 
		clk_cnt <= 'd0;
	else if (clk_cnt_en) 
		if (clk_cnt == FREQUENCE_CNT) 
			clk_cnt <= 'd0;
		else
			clk_cnt <= clk_cnt + 1'b1;
	else
		clk_cnt <= 'd0;
end
//generate the sclk
always @(posedge clk or negedge rst_n) begin
	if (!rst_n) 
		sclk <= CPOL;
	else if (clk_cnt_en) 
		if (clk_cnt == FREQUENCE_CNT)  	
			sclk <= ~sclk; 
		else 
			sclk <= sclk;
	else
		sclk <= CPOL;
end
//------------------------------------------
//to capture the edge of sclk
always @(posedge clk or negedge rst_n) begin
	if (!rst_n) begin
		sclk_a <= CPOL;
		sclk_b <= CPOL;
	end else if (clk_cnt_en) begin
		sclk_a <= sclk;
		sclk_b <= sclk_a;
	end
end

assign sclk_posedge = ~sclk_b & sclk_a;
assign sclk_negedge = ~sclk_a & sclk_b;
//----------------------------------------
//==============================================
//==============GENERATE BLOCKS=================
generate
	case (CPHA)
		0: assign sampl_en = sclk_posedge;
		1: assign sampl_en = sclk_negedge;
		default: assign sampl_en = sclk_posedge;
	endcase
endgenerate

generate
 	case (CPHA)
		0: assign shift_en = sclk_negedge;
 		1: assign shift_en = sclk_posedge;
		default: assign shift_en = sclk_posedge;
	endcase
endgenerate
//=============================================
//FSM-1
always @(posedge clk or negedge rst_n) begin
	if (!rst_n) 
		cstate <= IDLE;
	else 
		cstate <= nstate;
end
//FSM-2
always @(*) begin
	case (cstate)
		IDLE	: nstate = start ? LOAD : IDLE;
		LOAD	: nstate = SHIFT;
		SHIFT	: nstate = (shift_cnt == DATA_WIDTH) ? DONE : SHIFT;
		DONE	: nstate = IDLE;
		default: nstate = IDLE;
	endcase
end
//FSM-3
always @(posedge clk or negedge rst_n) begin
	if (!rst_n) begin
		clk_cnt_en	<= 1'b0	;
		data_reg	<= 'd0	;
		cs_n		<= 1'b1	;
		shift_cnt	<= 'd0	;
		finish <= 1'b0	;
	end else begin
		case (nstate)
			IDLE	: begin
				clk_cnt_en	<= 1'b0	;
				data_reg	<= 'd0	;
				cs_n		<= 1'b1	;
				shift_cnt	<= 'd0	;
				finish 		<= 1'b0	;
			end
			LOAD	: begin
				clk_cnt_en	<= 1'b1		;
				data_reg	<= data_in	;
				cs_n		<= 1'b0		;
				shift_cnt	<= 'd0		;
				finish 		<= 1'b0		;
			end
			SHIFT	: begin
				if (shift_en) begin
					shift_cnt	<= shift_cnt + 1'b1 ;
					data_reg	<= {data_reg[DATA_WIDTH-2:0],1'b0};
				end else begin
					shift_cnt	<= shift_cnt	;
					data_reg	<= data_reg		;
				end
				clk_cnt_en	<= 1'b1	;
				cs_n		<= 1'b0	;
				finish 		<= 1'b0	;
			end
			DONE	: begin
				clk_cnt_en	<= 1'b0	;
				data_reg	<= 'd0	;
				cs_n		<= 1'b1	;
				data_reg	<= 'd0	;
				finish 		<= 1'b1	;
			end
			default	: begin
				clk_cnt_en	<= 1'b0	;
				data_reg	<= 'd0	;
				cs_n		<= 1'b1	;
				data_reg	<= 'd0	;
				finish 		<= 1'b0	;
			end
		endcase
	end
end
//mosi output MSB first
assign mosi = data_reg[DATA_WIDTH-1];
//sample data from the miso line
always @(posedge clk or negedge rst_n) begin
	if (!rst_n) 
		data_out <= 'd0;
	else if (sampl_en) 
		data_out <= {data_out[DATA_WIDTH-1:0],miso};
	else
		data_out <= data_out;
end
//the function to get the width of data 
function integer log2(input integer v);
  begin
	log2=0;
	while(v>>log2) 
	  log2=log2+1;
  end
endfunction

endmodule
```

**从机verilog代码如下：**

```verilog
`timescale 1ns/1ps

module SPI_Slave
#(
	parameter	CLK_FREQUENCE	= 50_000_000		,	//system clk frequence
				SPI_FREQUENCE	= 5_000_000			,	//spi clk frequence
				DATA_WIDTH		= 8					,	//serial word length
				CPOL			= 1					,	//SPI mode selection (mode 0 default)
				CPHA			= 1					 	//CPOL = clock polarity, CPHA = clock phase
)
(
	input								clk			,	//system clk
	input								rst_n		,	//system reset
	input		[DATA_WIDTH-1:0]		data_in		,	//the data sent by miso
	input								sclk		,	//spi bus sclk
	input								cs_n		,	//spi bus slave select line
	input								mosi		,	//spi bus mosi input
	output								miso		,	//spi bus miso output
	output								data_valid	,	//the data received by mosi valid
	output	reg	[DATA_WIDTH-1:0]		data_out	 	//the data received by mosi,valid when data_valid is high
);

localparam	SFIFT_NUM = log2(DATA_WIDTH);

reg	[DATA_WIDTH-1:0]		data_reg	;	//the register to latch the data_in,also the shift register
reg	[ SFIFT_NUM-1:0]		sampl_num	;	//the counter to count the number of sample
reg							sclk_a		;	//sclk register to capture the edge of sclk
reg							sclk_b		;	//sclk register to capture the edge of sclk
wire						sclk_posedge;	//posedge of sclk
wire						sclk_negedge;	//negedge of sclk
reg							cs_n_a		;	//cs_n register to capture the edge of cs_n
reg							cs_n_b		;	//cs_n register to capture the edge of cs_n
wire						cs_n_negedge;	//negedge of cs_n to latch the data
wire						shift_en	;	//the signal to enable shift register to generate mosi
wire						sampl_en	;	//the signal to sample the data from miso
//------------------------------------------
//to capture the edge of sclk
always @(posedge clk or negedge rst_n) begin
	if (!rst_n) begin
		sclk_a <= CPOL;
		sclk_b <= CPOL;
	end else if (!cs_n) begin
		sclk_a <= sclk;
		sclk_b <= sclk_a;
	end
end

assign sclk_posedge = ~sclk_b & sclk_a;
assign sclk_negedge = ~sclk_a & sclk_b;
//------------------------------------------
//to capture the edge of sclk
always @(posedge clk or negedge rst_n) begin
	if (!rst_n) begin
		cs_n_a	<= 1'b1;
		cs_n_b	<= 1'b1;
	end else begin
		cs_n_a	<= cs_n		;
		cs_n_b	<= cs_n_a	;
	end
end

assign cs_n_negedge = ~cs_n_a & cs_n_b;
//------------------------------------------
//==============================================
//==============GENERATE BLOCKS=================
generate
	case (CPHA)
		0: assign sampl_en = sclk_posedge;
		1: assign sampl_en = sclk_negedge;
		default: assign sampl_en = sclk_posedge;
	endcase
endgenerate

generate
 	case (CPHA)
		0: assign shift_en = sclk_negedge;
 		1: assign shift_en = sclk_posedge;
		default: assign shift_en = sclk_posedge;
	endcase
endgenerate
//==================================================
//the register to latch the data_in
//also the shift register to generate the miso
always @(posedge clk or negedge rst_n) begin
	if (!rst_n) 
		data_reg <= 'd0;
	else if(cs_n_negedge)
		data_reg <= data_in;
	else if (!cs_n & shift_en) 
		data_reg <= {data_reg[DATA_WIDTH-2:0],1'b0};
	else
		data_reg <= data_reg;
end
//miso output MSB first
assign miso = !cs_n ? data_reg[DATA_WIDTH-1] : 1'd0;
//==================================================
//sample data from the mosi line
always @(posedge clk or negedge rst_n) begin
	if (!rst_n) 
		data_out <= 'd0;
	else if (!cs_n & sampl_en) 
		data_out <= {data_out[DATA_WIDTH-2:0],mosi};
	else
		data_out <= data_out;
end
//the counter to count the number of sampled data bit
always @(posedge clk or negedge rst_n) begin
	if (!rst_n) 
		sampl_num <= 'd0;
	else if (cs_n)
		sampl_num <= 'd0;
	else if (!cs_n & sampl_en) 
		if (sampl_num == DATA_WIDTH)
			sampl_num <= 'd1;
		else
			sampl_num <= sampl_num + 1'b1;
	else
		sampl_num <= sampl_num;
end
//the received data valid
assign data_valid = sampl_num == DATA_WIDTH;
//the function to get the width of data 
function integer log2(input integer v);
  begin
	log2=0;
	while(v>>log2) 
	  log2=log2+1;
  end
endfunction

endmodule
```

## 二、AMBA总线

AMBA(Advanced Microcontroller Bus Architecture)总线结构（它不是芯片与外设之间的接口，而是ARM内核与芯片上其他元件进行通信的接口。）包括：

**APB(Advanced Peripheral Bus)：**主要用在低速且低功率的外围，可针对外围设备作功率消耗及复杂接口的最佳化。

**AHB(Advanced High-performance Bus)：**主要是针对高效率、高频宽及快速系统模块所设计的总线，它可以连接如微处理器、芯片上或芯片外的内存模块和DMA等高效率模块。

一般的接法如上。高速的接在AHB上，低速的接在APB上。中间有一个AHB2APB的桥。你可以理解这个桥也是一个高速的AHB Slave。

**AXI(Advanced eXtensible Interface):**高速度、高带宽，管道化互联，单向通道，只需要首地址，读写并行，支持乱序，支持非对齐操作，有效支持初始延迟较高的外设，连线非常多。

### 1. APB总线

APB主要用在低速的IP接口上，协议简单，时钟clock也比较低，power较小。在APB总线系统中，**只有一个master，其他的都是slave**。

**特点：**

- **可工作在高频下**；
- **协议简单**：无复杂的时序；
- **同步总线**：总线上所有的transaction（读写操作）都依赖于时钟的上升沿；
- **一主多从**：一般情况下，APB挂在AHB总线系统下，通过AHB-APB Bridge将事务在AHB总线系统之间进行转化，此时Bridgre即为APB的master，其他的外围设备均为slave。
- **接口简单**：相对应AXI、AHB来说，接口比较简单；
- **低功耗**
- **可连接多种外围设备**：I2C、SPI、Timer、Keypad、UART

![w9ColQ.png](https://s1.ax1x.com/2020/09/02/w9ColQ.png)

APB总线的架构不像AHB总线是多主设备的架构，**APB总线的唯一主设备是APB桥**（与AXI或APB相连），因此**不需要仲裁一些Request/grant信号**。

**相关信号：**

| 信号名称    | 描述                                                         |
| :---------- | :----------------------------------------------------------- |
| PCLK        | APB总线的时钟信号，所以事务上升沿有效                        |
| PRESETn     | APB总线的复位信号，低电平有效，一般直接源于系统的复位信号    |
| PADDR[31:0] | 32位地址信号线                                               |
| PSELx       | 从机选通信号线，源于主机对地址的解码。位数取决于从机的个数，一位对应一个从机 |
| PENABLE     | Transaction使能信号，为高时，表示当前信号有效                |
| PWRITE      | 读写控制信号，高电平表示写，低电平表示读                     |
| PRDATA      | 读数据总线，传输读操作时的数据。最高支持32位宽               |
| PWDATA      | 写数据总线，传输写操作时的数据。最高支持32位宽               |

[![wpja8A.png](https://s1.ax1x.com/2020/09/02/wpja8A.png)](https://imgchr.com/i/wpja8A)

因为他没有分别的读写握手信号，在读写过程中，addr/enable/sel也不可变的，两组数据信号，可能只是为了简化逻辑。

**传输状态图：**

![wCZCSx.png](https://s1.ax1x.com/2020/09/03/wCZCSx.png)

1. **IDLE：**系统初始化状态，此时没有传输操作，也没有选中任何从模块。
2. **SETUP：**启动状态，当有传输要进行时，PSELx=1,，PENABLE=0，系统进入SETUP状态，并只会在SETUP状态停留一个周期。当PCLK的下一个上升沿到来时，系统进入ENABLE状态。
3. **ENABLE：**在总线进入SETUP状态的下一个时钟上升沿处，需将PENABLE信号拉高进入ENABLE状态。在这个上升处，master必须保持PADDR、PSEL、PWRITE不变。传输也只会在ENABLE状态维持一个周期，在经过SETUP与ENABLE状态之后就已完成。之后如果没有传输要进行，就进入IDLE状态等待；如果有连续的传输，则进入SETUP状态。

**写传输信号图：**

<img src="https://s1.ax1x.com/2020/09/03/wCud54.png" alt="wCud54.png" style="zoom:67%;" />

如图所示，一次传输过程中，**psel保持两个周期不变**，且在此期间，paddr、pwrite也保持不变，**penable在psel有效的第2个周期有效**。为了降低功耗，地址信号和写信号将在传输后不再改变，直到发生下一次传输。协议仅要求使能信号有个规则的跳变，背靠背传输情况下，选择和写信号可能有小跳变。

推荐逻辑写法：

```verilog
assign wr = psel & pwrite & (penable);
always @(posedge pclk or negedge presetn)
begin
    if(!presetn)
    begin
        REG_A <= 32’h0;
    end
    else if(wr & paddr = REG_A_ID)
    begin
        REG_A <= pwdata;
    End
end
```

**读传输信号图：**

<img src="https://s1.ax1x.com/2020/09/03/wCK8Fe.png" alt="wCK8Fe.png" style="zoom:67%;" />

PWRITE=0表示读传输； 读传输时各信号的时序和写时一样，在读传输中，从机必须在ENABLE周期提供数据，数据在ENABLE末尾的时钟上升沿被采样；

**推荐逻辑写法：**

```verilog
assign rd = psel & (~pwrite) & (penable) ;
always @(*)
begin
    if(rd)            //setup 
    begin
        case(paddr)
        REG_A_ID    : prdatanxt = REG_A;
        REG_B_ID    : prdatanxt = REG_B;
        ……
        default        : prdatanxt = 32’h0;
        endcase
    end
    else
    begin
        prdatanxt = 32’h0;
    end
end
always @(posedge pclk or negege present)
begin
    if(!presetn)
    begin
        prdata <= 32’h0;
    end
    else    begin
        prdata <=prdatanxt;
    End
end
```

关于PREADY的相关信号

### 2. AHB总线

AHB总线的强大之处在于它可以将微控制器（CPU）、高带宽的片上RAM、高带宽的外部存储器接口、DMA总线主机、各种拥有AHB接口的控制器等等连接起来构成一个独立的完整的SOC系统，不仅如此，还可以通过AHB-APB桥来连接APB总线系统。AHB可以成为一个完整独立的SOC芯片的骨架。

**AHB总线的基本特性：**

- 分块处理
- 单周期总线主机移交
- 单时钟沿操作
- 无需三态门的实现方式
- 更宽的数据总线架构（64位或者128位）
- 流水线操作
- 可支持多个总线主设备（最多16个）

**AHB总线的组成：**

AHB总线由**AHB总线主机(Master)、AHB总线从机(Slave)和Infrastructure构成**。Infrastructure由仲裁器、数据多路选择器、地址控制多路选择器、译码器构成。

AMBA AHB 总线协议设计使用一个中央多路选择器互联方案。该方案中，所有总线主机设备输出地址和控制信号来指示它们想执行的传输，同时仲裁器决定哪一个主机能够将它的地址和控制信号连通到所有的从机。当然也需要一个译码器来控制读数据和响应多路信号选择器，多路信号选择器选中来自传输中所包含从机的适当信号。

下图实现包含三个主机和四个从机的AMBA AHB设计的结构要求。

![wCtFje.png](https://s1.ax1x.com/2020/09/03/wCtFje.png)

**AHB信号描述：**

所有 AMBA 信号的命名都用名称的第一个字母来指示信号和哪个总线相关联。信号名称中用一个小写的 n 表示该信号低电平有效，否则信号的名称总是用大写字母来表示。

测试信号有一个前缀T而与总线类型无关。

| 名称                    | 来源     | 描述                                                         |
| ----------------------- | -------- | ------------------------------------------------------------ |
| 总线时钟  HCLK          | 时钟源   | 时钟为所有总线传输提供时基。所有信号时序都和HCLK的上升沿相关 |
| 复位 HRESETn            | 复位模块 | 总线复位信号，低电平有效，用来复位系统和时钟总线。这是唯一低电平有效的信号 |
| 地址总线 HADDR[31:0]    | 主机     | 32位地址线                                                   |
| 传输类型 HTRANS[1:0]    | 主机     | 表示当前传输的类型，可以是连续，不连续，空闲和忙             |
| 传输方向 HWRITE         | 主机     | 该信号为高表示一个写传输，为低表示一个读传输                 |
| 传输大小 HSIZE[2:0]     | 主机     | 表示传输的大小，三位表示0...7，分别对应8,16,32,64,128,256,512,1024bits |
| 突发类型 HBRUST[2:0]    | 主机     | 表示传输是否组成了突发的一部分。支持4,8,16个节拍的突发传输，可以是增量或回环。 |
| 保护控制 HPROT[3:0]     | 主机     | 提供总线访问的附加信息，主要是给那些希望执行某种保护级别的模块使用的。<br />这个信号指示当时传输是否为预取指令或者数据传输，同时也表示传输是保护模式访问还是用户模式访问。<br />对带存储器管理单元的总线主机而言这些信号也用来指示当前传输是高速缓存的(cache)还是缓冲的(buffer)。 |
| 写数据总线HRDATA[31:0]  | 主机     | 写数据总线用来在写操作期间从主机到总线从机传输数据。建议最小的数据总线宽度为 32 位。在要求高带宽运行时扩展（数据总线）还是很容易的。 |
| 从机选择 HSELx          | 译码器   | 每个 AHB 从机都有自己独立的从机选择信号并且用该信号来表示当前传输是否是打算送给选中的从机。该信号是地址总线的简单组合译码。 |
| 读数据总线 HRDATA[31:0] | 从机     | 读数据总线用来在读操作期间从总线从机向总线主机传输数据。建议最小的数据总线宽度为 32 位。在要求高带宽运行时扩展（数据总线）还是很容易的。 |
| 传输完成 HREADY         | 从机     | **当 HREADY 为高时表示总线上的传输已经完成**。在扩展传输时该信号可能会被拉低。 注意：**总线上的从机要求 HREADY 作为输入输出信号。** |
| 传输响应 HRESP[1:0]     | 从机     | 传输响应给传输状态提供了附加信息。提供四种不同的响应： OKEY、 ERROR、 RETRY 和 SPLIT。 |

AMBA AHB也有许多信号请求支持多主机操作。这些仲裁信号用于点对点连接， 下表中后缀x用来表示信号来自模块x。例如，一个系统中会有许多的信号HBUSREQx，比如HBUSREQarm， HBUSREQdma和HBUSREQtic。

| 名称                       | 来源             | 描述                                                         |
| -------------------------- | ---------------- | ------------------------------------------------------------ |
| 总线请求 HBUSREQx          | 主机             | 从总线主机x传向总线仲裁器用来表示该主机请求（控制）总线的信号 。 系统中每个总线主机都有一个HBUSREQx 信号，最多16个总线主机。 |
| 锁定的传输 HLOCKx          | 从机             | 当该信号为高时表示主机请求锁定对总线的访问并且在该信号为低之前其他主机不应该被允许授予总线。 |
| 总线授予HGRANTx            | 仲裁器           | 该信号用来表示总线主机 x 目前是优先级最高的主机。当 HREADY 为高时传输结束，地址/控制信号的所有权发生改变。所以主机应在 HREADY 和 HGRANTx都为高时获得对总线的访问。 |
| 主机号HMASTER[3:0]         | 仲裁器           | 这些来自仲裁器的信号表示哪个总线主机正在执行传输和被支持分块传输的从机用来确定哪个主机正在尝试一次访问。HMASTER的时序和地址以及控制信号对齐。 |
| 锁定顺序 HMASTLOCK         | 仲裁器           | 表示当前主机正在执行一个锁定顺序的传输。该信号和 HMASTER 有相同的时序。 |
| 分块完成请求 HSPLITx[15:0] | 从机（支持分块） | 从机用这 16 位的分块总线来指示仲裁器总线主机应该被允许重试一个分块传输。分块总线上的每一位对应一个总线主机。 |

**AHB总线操作概括**

在一次 AMBA AHB 传输开始之前总线主机必须被授予访问总线。这个过程**开始于总线主机向仲裁器断言一个请求信号**。仲裁器指示主机何时能够被授予使用总线。**被授权的总线主机通过驱动地址和控制信号来发起一次 AMBA AHB 传输。这些信号提供关于地址、方向和传输宽度的信息，以及表示传输类型是否为一次突发传输的部分。**

允许有两种不同类型的突发传输：

- 增量突发，在地址边界处不回环；
- 回环突发，在特定的地址边界上回环。

写数据总线用来将数据从主机传输到从机上，而读数据总线用来将数据从从机传输到主机上。每次传输包含：

- 一个地址和控制周期；

- 一个或多个数据周期。

地址不长期有效所以所有从机必须在这个时段（传输地址时）采样地址。然而，通过**HREADY 信号可以延长数据**。当该信号为低时导致在传输中插入等待状态同时允许从机有额外的时间提供或者采样数据。在传输中从机通过使用响应信号来表示状态，HRESP[1:0]：

- OKAY 响应用来表示传输进展正常并且当 HREADY 变高时表示传输成功完成。
- ERROR 响应表示发生了一个传输错误并且传输失败。
- RETRY 和 SPLIT 两个传输响应都表示传输不能立刻完成，但是总线主机应该继续尝试传输。

在常规操作中主机被允许在仲裁器授予另一个主机访问总线之前完成一个特定突发的所有传输。然而，为了避免过多的仲裁延时可能允许仲裁器打断一个突发并且这种情况下主机必须（申请）重新仲裁总线以完成剩下的突发传输。

**基本传输：**

一笔传输由如下两部分组成：

- 地址阶段：**一个周期** 
- 数据阶段：**一个或多个周期**，由HBURST信号决定需要几个有效周期，可以由HREADY发出请求延长一个周期。

**没有等待状态的single transfer**

- 第一个周期的上升沿，主机将地址信息和控制信息发送到总线上；
- 第二个周期的上升沿，**从机采样地址和控制信号，并将HREADY拉高**；如果是写操作，主机会在第二个周期的上升沿过后传输要写入的数据；如果是读操作，从机会在HREADY信号拉高后将读取的数据写入总线；
- 第三个周期的上升沿，如果是写操作，主机获取HREADY高信号，表明从机已成功接收数据，操作成功；如果是读操作，主机获取HREADY高信号，表明此时的读数据有效并且接收下来，操作成功。**需要注意，HREADY信号在数据有效期间必须为高，并且延续到第三个周期的上升沿之后，确保主机的正确采样。**

<img src="https://s1.ax1x.com/2020/09/04/wkPkR0.png" alt="wkPkR0.png" style="zoom:67%;" />

**多个single transfer的pipeline操作**

扩展数据周期的一个负效应是必须延长相应的下一笔传输的地址周期。A和C为零等待传输，B加入了一个等待周期，因此相应的C地址周期要进行扩展。

- 第一个周期，主机发起一个操作A，并驱动地址和控制信号；
- 第二个周期，从机收到了来自总线的请求，将HREADY信号拉高；
- 第二个周期上升沿后，主机发现有操作B需要执行，并且检查到上一周期的HREADY为高，则发起第二个操作B；
- 第三个周期，主机获取HREADY信号为高，表示操作A已经完成；
- 第三个周期上升沿后，主机发现有操作C需要执行，并且检查到上一周期的HREADY为高，则发起第三个操作C；
- 第三个周期上升沿后，从机由于繁忙插入了一个等待状态，将HREADY拉低；
- 第四个周期，主机获取HREADY信号为低，知道从机希望等待，于是主机保持和上一拍一样的信号；
- 第四个周期，从机处理完了事务，将HREADY信号拉高，表示可以继续处理；
- 第五个周期，主机获取HREADY信号为高，知道从机已经可以处理B操作；
- 第五个周期上升沿后，B操作完成；
- 第六个周期上升沿后，C操作完成。

需要注意几点：

**HREADY在一定程度上表示了从机的pipeline能力**，在AHB中是2个pipe，也就是总线上最多存在2个未处理完的transfer。**只有当总线上未完成的transfer少于2个时，主机才能发起操作。**

![wkZt39.png](https://s1.ax1x.com/2020/09/04/wkZt39.png)

**突发操作（Burst）信号：**

在介绍突发传输之前，我们再来看下AHB控制信息。

**HWRITE** ：这个信号是读写控制信号，也即transfer的方向控制信号。 高电平表示写操作，低电平表示读操作。

**HSIZE** ：这个信号是指明单次传输的数据宽度。表示传输的大小，三位表示0…7,分别对应8bits(byte), 16bits(halfword), 32bits(word), 64bits, 128bits, 256bits, 512bits, 1024bits。

**HPROT[3:0]** ：为transfer提供额外的访问保护和控制权限信号。一般不用，在此不做介绍。

**HTRANS[1:0]** ：进行一次传输时的传输类型，这个信号由主机根据自己要进行的传输类型生成的控制信号。一共4种类型

| HTRANS[1:0] | 传输类型 | Description                                                  |
| ----------- | -------- | ------------------------------------------------------------ |
| 00          | IDLE     | **主设备占用总线，但没进行传输**。两次突发传输中间主设备可发IDLE此时就算从机被使能，也不会从总线上获取任何的数据信号。如果此时从机被选中，那么每一个IDLE周期从机都要通过HRESP[1:0]返回一个OKAY响应 |
| 01          | BUSY     | **主设备占用总线，但是在突发传输过程中还没有准备好进行下一次传输**。一次突发传输中间主设备可发BUSY 这时**从机不会从总线上收取数据而是等待**，并且通过HRESP[1:0]返回一个OKAY响应。需要注意的是，这个**传输需要给出下一拍的地址和控制信号**，尽管从机不会去采样。 |
| 10          | NONSEQ   | **表明一次单个数据的传输或者一次突发传输的第一个数据**。地址和控制信号与上一次传输无关 |
| 11          | SEQ      | **突发传输中剩下的传输是连续传输并且地址是和前一次传输有关的。**控制信息和前一次传输一样。地址等于前一次传输的地址加上传输大小（字节）。在回环突发的情况下传输地址在地址边界处回环，回环值等于传输大小乘以传输的次数（4、 8 或者 16 其中之一）。 |

这个信号只有在突发传输中出现。当从机收到这个信号时，表明当前的传输是一个突发中的某一拍。这时，总线上的控制信号应当与之前的保持一致，地址视情况递增或者回环。（这些信号其实是由主机决定的，从机不用考虑，只需要单方面接收即可）

参照下图：

- T1，主机传入地址和控制信号，因为是新的突发传输开始，所以传输的类型是NONSEQ；

- T2，由于主机不能在第二个周期里处理第二拍，所以主机使用BUSY传输来为自己延长一个周期的时间。注意，虽然是延长了一个周期，但是主机需要给出第二个传输的地址和控制信号；
- T3，从机采集到了主机发来的BUSY，知道主机需要等待一拍，所以从机会忽略这个BUSY传输；
- T3，主机发起了第二个传输，因为是同一个burst的第二个传输，所以传输的类型是SEQ；
- T5，从机将HREADY信号拉低，告诉主机需要等待一个周期；
- T8时刻完成最后一个传输。

需要注意的 虽然从机会忽略掉BUSY传输，但是主机也需要给出下一拍的地址和控制信号。

![wk3xyD.png](https://s1.ax1x.com/2020/09/04/wk3xyD.png)

**关于突发操作：**

- AMBA AHB 协议定义了4、8和16拍突发，也有未定长度的突发和信号传输。

- 协议支持**增量**和**回环**操作：增量突发访问连续地址并且突发中的每次传输地址仅是前一次地址的一个增量；

- 对于回环突发，**如果传输的起始地址并未和突发（x 拍）中字节总数对齐（与起始地址呈倍数关系）**那么突发传输地址将在达到边界处回环。例如，一个四拍回环突发的字（4 字节）访问将在16 字节边界回环。因此，如果传输的起始地址是 0x34，那么它将包含四个到地址0x34、 0x38、 0x3C 和 0x30；突发信息通过使用 HBURST[2:0]并且 8 种可能的类型在中定义如下：

  | HBURST[2:0] | 类型   | 描述                 |
  | ----------- | ------ | -------------------- |
  | 000         | SINGLE | 单一传输             |
  | 001         | INCR   | 未指定长度的增量突发 |
  | 010         | WRAP4  | 4拍回环突发          |
  | 011         | INCR4  | 4拍增量突发          |
  | 100         | WRAP8  | 8拍回环突发          |
  | 101         | INCR8  | 8拍增量突发          |
  | 110         | WRAP16 | 16拍回环突发         |
  | 111         | INCR16 | 16拍增量突发         |

- 突发禁止超过 1KB 的地址边界。因此重要的是主机不要尝试发起一个将要超过这个边界的定长增量突发。将执行单个传输时使用未指定长度的增量突发理解为长度为一的突发比较合理。**一个增量突发可以是任何长度，但是（长度）上限由地址不能超过 1KB 边界这个事实限定了。**

  注：突发大小表示突发的节拍数量，并不是一次突发传输的实际字节数量。一次突发传输的数据总量可以用节拍数乘以每拍数据的字节数来计算，每拍字节数由 HSIZE[2： 0]指示。**所有突发传输必须将地址边界和传输大小对齐。**例如，字传输必须对齐到字地址边界（也就是 A[1： 0] = 00），半字传输必须对齐到半字地址边界（也就是 A[0] = 0）。

  当一个突发不允许完成的特定情况下对任一从机设计而言如果突发提前终止那么利用突发信息能够采取正确的动作显得很重要。从机能够通过监控 HTRANS 信号决定一个突发何时提前终止并且确保在突发开始之后每次传输有连续或者忙的标记。如果产生一个非连续或者空闲传输那么这表明一个新的突发已经开始因此前一次突发一定已经终止。

  如果总线主机因为失去对总线的占有而不能完成一次突发那么它必须在下一次获取访问总线时正确地重建突发。例如，如果一个主机仅完成了一个四拍突发的一拍那么它必须用一个未定长度突发来执行剩下的三拍突发。

  下图表示了一个四拍回环突发并且第一次传输伴随一个附加等待状态。

  <img src="https://s1.ax1x.com/2020/09/05/wEk5lR.png" alt="wEk5lR.png" style="zoom:87%;" />

  作为一次四拍字突发传输，地址将会在 16 字节边界回环，因此传输到地址 0x3C之后接下来传输的地址是 0x30。 下图表示了（回环突发）和增量突发的唯一不同，既是地址连续通过了 16 字节边界，并不回环，而是递增。

  <img src="https://s1.ax1x.com/2020/09/05/wEA7gs.png" alt="wEA7gs.png" style="zoom:88%;" />

**地址译码：**

对于每个总线上的从机来说使用一个中央地址译码器提供选择信号， HSELx。选择信号是高位地址信号的组合译码，并且建议使用简单的译码方案以避免复杂译码逻辑和确保高速操作。

**从机只能在 HREADY 信号为高时采样地址和控制信号以及 HSELx**， HSELx 为高表示当前传输已经完成。在特定的情况下有可能在 HREADY 为低时采样 HSELx，但是被选中的从机将会在当前传输完成后变更。

**能够分配给单个从机的最小地址空间是 1KB**。**所有总线主机必须被设计为不能执行超过 1KB 地址边界的增量传输**，因此确保了一个突发绝不会超过地址译码的边界。

在系统设计中如果有包含一个存储器映射并未完全填满（存储空间）的情况时应该设置一个额外的默认从机以在访问任何不存在的地址空间时提供响应。如果一个非连续或者连续传输试图访问一个不存在的地址空间时这个默认从机应该提供一个 ERROR 响应。空闲或者忙传输访问不存在的空间（默认从机）应该给出一个零等待状态的 OKAY 响应。典型默认从机的功能将以作为中央地址译码器的一部分来实现。

![wEnFA0.png](https://s1.ax1x.com/2020/09/05/wEnFA0.png)

**从机传输响应：**

在主机发起传输后，由从机决定传输该如何进行。 AHB 规范中没有做出总线主机在传输已经开始后取消传输的规定。只要从机被访问那它必须提供一个表示传输状态的响应。 HREADY 信号被用来扩展传输并且和响应信号 HRESP[1： 0]相结合，以提供传输状态。从机能够用许多种方式来完成传输。它能：

- 立刻完成传输；
- 插入一个或者多个等待状态以允许有时间来完成传输；
- 发出一个错误信号来表示传输失败；
- 延时传输的完成，但是允许主机和从机放弃总线，把总线留给其他传输使用。

传输完成：

- HREADY 信号用来扩展一次 AHB 传输的数据部分。当 HREADY 信号为低时表示传输将被扩展而当其为高时表示传输完成。

- 注：每个从机必须有一个预先确定的在从机放弃总线之前插入的最大等待状态数目，以便能够计算访问总线的延时。建议但不强制规定，从机不要插入多于 16 个等待状态以阻止任何单个访问将总线锁定较长的时钟周期。

传输响应：

- 典型的从机将会用 HREADY 信号在传输中插入适当数量的等待状态而传输在HREADY 为高时完成并且给出 OKAY 响应，表示传输成功完成。
- ERROR 响应被从机用来表示某种形式的错误条件和相关的传输。典型的是被用作保护错误，例如试图写一个只读的存储空间。
- SPLIT 和 RETRY 响应组合允许从机延长传输完成的时间，但是释放总线给其他主机使用。这些响应组合通常仅由有高访问延时的从机请求并且从机能够利用这些响应编码来确保其他主机在长时间内不被阻止访问总线。关于SPLIT和RETRY的完整描述参见分块和重试。

当从机需要插入一定数量的等待状态优于决定将要给出何种响应时从机必须将响应驱动为 OKAY。

HRESP[1： 0]的编码、传输响应信号和每个响应的描述参见下表：

| HRESP[1] | HRESP[0] | 响应  | 描述                                                         |
| -------- | -------- | ----- | ------------------------------------------------------------ |
| 0        | 0        | OKAY  | 当 HREADY 为高表示传输已经成功完成。 OKAY 响应也被用来插入任意一个附加周期，当 HREADY 为低时，优先给出其他三种响应之一。 |
| 0        | 1        | ERROR | 该响应表示发生了一个错误。错误条件应该发信号给 总线主机以便让主机意识到传输失败。 一个错误条件需要双周期响应。 |
| 1        | 0        | RETRY | RETRY（重试）信号表示传输并未完成，因此总线主机应该重试传输。主机应该继续重试传输直到完成为止。 要求双周期的RETRY 响应。 |
| 1        | 1        | SPLIT | 传输并未成功完成。总线主机必须在下一次被授予访问总线时重试传输。当传输能够完成时从机将请求代替主机访问总线。 要求双周期的 SPLIT 响应。 |

**双周期响应：**

仅有 OKAY 响应可以在单个周期里给出。 **ERROR、 SPLIT 和 RETRY 响应需要至少两个周期。**为了完成这些响应中的任意一个那么在倒数第二个（最后一个的前一个）周期从机驱动 HRESP[1： 0]以表示 ERROR、 RETRY 或者 SPLIT 并同时驱动 HREADY 为低以给传输扩展一个额外的周期。在最后一个周期 HREADY 被驱动为高电平以结束传输，同时HRESP[1： 0]保持驱动以表示 ERROR、 RETRY 或者 SPLIT。

如果从机需要两个以上的周期以提供 ERROR、 SPLIT 或者 RETRY 响应那么额外的等待状态可能会在传输开始时被插入。在这段时间 HREADY 信号将为低电平同时响应必须被设为 OKAY。

需要双周期响应是因为总线通道的本质特征。在从机开始发出 ERROR、 SPLIT 或者RETRY 中任何一个响应时接下来传输的地址已经广播到总线上了。**双周期响应允许主机有足够的时间来取消该地址并且在开始下一次传输之前驱动 HTRANS[1： 0]为空闲传输。**

对于 SPLIT 和 RETRY 响应接下来的传输必须取消因为在当前传输完成之前禁止下一次传输发生。然而，对于 ERROR 响应，由于当前传输不被重复，所以可以选择完成接下来的传输。

下图表示了一次RETRY操作的例子。

主机从地址 A 发起传输；这次传输在接收到响应之前主机将地址移动到 A + 4；

从机在地址 A 不能立刻完成传输因此从机发出一个 RETRY 响应。该响指示主机在地址 A 的传输无法完成并且在地址 A + 4 的传输被取消而用空闲传输替代。

<img src="https://s1.ax1x.com/2020/09/05/wEKc0s.png" alt="wEKc0s.png" style="zoom:67%;" />

下图表示了一个传输中从机请求一个周期来决定将要给出的响应（在HRESP为OKAY的时间段），之后从机用一个双周期的ERROR响应结束了传输。

<img src="https://s1.ax1x.com/2020/09/05/wEKIcF.png" alt="wEKIcF.png" style="zoom:67%;" />

**分块与重试：**

**分块和重试响应给从机提供了在无法立刻给传输提供数据时释放总线的机制。这两种机制都允许在总线上结束传输因此允许更高优先级的主机能够访问主机。**

分块（SPLIT）和重试（RETRY）的不同之处在于仲裁器在发生 SPLIT 和 RETRY 后分配总线的方式：

- **对于 RETRY 而言仲裁器将继续使用常规优先级方案因此只有拥有更高优先级的主机将获准访问总线；**
- **对于 SPLIT 传输而言仲裁器将调整优先级方案以便其他任何主机请求总线即能获得访问（总线）**，即使是优先级较低的主机。为了完成一个 SPLIT 传输从机必须通知仲裁器何时数据可用。

SPLIT 传输增加了仲裁器和从机的复杂性，但是却有可以完全释放总线给其他主机使用的优点，但是 RETRY（响应）的情况就只允许较高优先级的主机使用总线。

总线主机应该以同样的方式来对待 SPLIT 和 RETRY（响应）。主机应该继续请求总线并尝试传输直到传输成功完成或者遇到 ERROR 响应时终止。

**数据总线：**

**为了不使用三态驱动而又允许执行AHB系统所以要求分开读和写数据总线。**最小的数据宽度规定为 32 位，但是总线宽度却可以增加，参见关于AHB数据总线的位宽这一节中的描述。

HWDATA[31： 0]：

写数据总线在写传输期间由总线主机驱动。如果传输是扩展的那么总线主机必须保持数据有效直到传输完成，由 HREADY 为高表示。

**所有传输必须对齐到和传输大小相等的地址边界。例如，字传输必须对齐到字地址边界（也就是 A[1： 0] = 00），半字传输必须对齐到半字地址边界（也就是 A[0] = 0）。**

对于宽度小于总线宽度的传输，例如一个在 32 位总线上的 16 位传输，那么总线主机仅需要驱动相应的字节通道。从机必须负责从正确的字节通道选择写数据。 下面两个表中分别表示了小端系统和大端系统中哪个字节通道有效。如果有要求，这些信息可以在更宽的总线应用中扩展。传输大小小于数据总线宽度的突发传输将在每拍突发中有不同有效字节通道。

有效字节通道取决于系统的端结构，但是 AHB 并不指定要求的端结构。因此，总线上所有主机和从机的端结构相同这点很重要。

HRDATA[31： 0]：

读数据总线在读传输期间由合适的从机驱动。如果从机通过拉低 HREADY 扩展读传输那么从机只需要在传输的最后一个周期提供有效数据，由 HREADY 为高表示。对于宽度小于总线宽度的传输从机仅需要在有效的字节通道提供有效数据，如下两个表所示。总线主机负责从正确的字节通道中选择数据。当传输以 OKAY 响应完成时从机仅需提供有效数据。 SPLIT、 RETRY 和 ERROR 响应不需要提供有效的读数据。

关于仲裁、分块传输总线移交等：https://www.cnblogs.com/mikewolf2002/p/10909918.html。

### 3. AHB、APB、AXI总线对比

AHB主要是针对高效率、高频宽及快速系统模块所设计的总线，它可以连接如微处理器、芯片上或芯片外的内存模块和DMA等高效率模块。

APB主要用在低速且低功率的外围，可针对外围设备作功率消耗及复杂接口的最佳化。APB在AHB和低带宽的外围设备之间提供了通信的桥梁，所以APB是AHB或ASB的二级拓展总线。

AXI：高速度、高带宽，管道化互联，单向通道，只需要首地址，读写并行，支持乱序，支持非对齐操作，有效支持初始延迟较高的外设，连线非常多。

几种AMBA总线的性能对比分析

| 总线     | AXI                                                          | AHB                                                          | APB                                                  |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ---------------------------------------------------- |
| 总线宽度 | 8，16，32，64，128，256，512，1024                           | 32，64，128，256                                             | 8，16，32                                            |
| 地址宽度 | 32                                                           | 32                                                           | 32                                                   |
| 通道特性 | 读写地址通道、读写数据通道均独立                             | 读写地址通道共用读写数据通道                                 | 读写地址通道共用读写数据通道<br />不支持读写并行操作 |
| 体系结构 | 多主/从设备<br />仲裁机制                                    | 多主/从设备<br />仲裁机制                                    | 单主（桥）设备/多从<br />无仲裁                      |
| 数据协议 | 支持流水/分裂传输<br />支持Burst传输<br />支持乱序访问<br />字节/半字/字<br />大小端对齐<br />非对齐操作 | 支持流水/分裂传输<br />支持Burst传输<br />支持乱序访问<br />字节/半字/字<br />大小端对齐<br />不支持非对齐操作 | 一次读/写传输占两个时钟周期<br />不支持突发传输      |
| 传输方式 | 支持读写并行操作                                             | 不支持读写并行操作                                           | 不支持读写并行操作                                   |
| 时序     | 同步                                                         | 同步                                                         | 同步                                                 |
| 互联     | 多路                                                         | 多路                                                         | 无定义                                               |

**AHB突发传输和AXI突发传输的特点：**

AHB协议需要一次突发传输的所有地址，地址与数据锁定对应关系，后一次突发传输必须在前次传输完成才能进行。

AXI只需要一次突发的首地址，可以连续发送多个突发传输首地址而无需等待前次突发传输完成，并且多个数据可以交错传递，此特征大大提高了总线的利用率。

AHB总线与AXI总线均适用于高性能、高带宽的SoC系统，但AXI具有更好的灵活性，而且能够读写通道并行发送，互不影响；更重要的是，AXI总线支持乱序传输，能够有效地利用总线的带宽，平衡内部系统。因此SoC系统中，均以AXI总线为主总线，通过桥连接AHB总线与APB总线，这样能够增加SoC系统的灵活性，更加合理地把不同特征IP分配到总线上。

### 4. AXI三种总线对比

**三种AXI总线：**

- AXI4：（For high-performance memory-mapped requirements.）主要面向高性能地址映射通信的需求，是面向地址映射的接口，允许最大 256 轮的数据突发传输；

- AXI4-Lite：（For simple, low-throughput memory-mapped communication ）是一个轻量级的地址映射单次传输接口，占用很少的逻辑单元。

- AXI4-Stream：（For high-speed streaming data.）面向高速流数据传输；去掉了地址项，允许无限制的数据突发传输规模。

**总线组成部分：**

AXI 协议将读地址通道，读数据通道，写地址通道，写数据通道，写响应通道分开，各自通道都有自己的握手协议。每个通道互不干扰却又彼此依赖。这是 AXI 高效的原因之一。

**AXI4 总线和 AXI4-Lite 总线**具有相同的组成部分：

- 读地址通道，包含 ARVALID, ARADDR, ARREADY 信号；

- 读数据通道，包含 RVALID, RDATA, RREADY, RRESP 信号；

- 写地址通道，包含 AWVALID，AWADDR, AWREADY 信号；

- 写数据通道，包含 WVALID, WDATA，WSTRB, WREADY 信号；

- 写应答通道，包含 BVALID, BRESP, BREADY 信号；

- 系统通道，包含：ACLK，ARESETN 信号。

而 **AXI4-Stream 总线**的组成有：

- ACLK 信号：总线时钟，上升沿有效；

- ARESETN 信号：总线复位，低电平有效

- TREADY 信号：从机告诉主机做好传输准备；

- TDATA 信号：数据，可选宽度 32,64,128,256bit

- TSTRB 信号：每一 bit 对应 TDATA 的一个有效字节，宽度为 TDATA/8

- TLAST 信号：主机告诉从机该次传输为突发传输的结尾；

- TVALID 信号：主机告诉从机数据本次传输有效；

- TUSER 信号 ：用户定义信号，宽度为 128bit

**ZYNQ中的AXI 接口：**

- AXI-GP 接口（4 个）：是通用的 AXI 接口，包括两个 32 位主设备接口和两个 32 位从设备接口，用过该接口可以访问 PS 中的片内外设。

- AXI-HP 接口（4 个）：是高性能 / 带宽的标准的接口，PL 模块作为主设备连接。主要用于 PL 访问 PS 上的存储器（DDR 和 On-Chip RAM）

- AXI-ACP 接口（1 个）：是 ARM 多核架构下定义的一种接口，中文翻译为加速器一致性端口，用来管理 DMA 之类的不带缓存的 AXI 外设，PS 端是 Slave 接口。

**AXI Interconnect 的主要作用：**

当存在多个主机以及从机器时，AXIInterconnect 负责将它们联系并管理起来。由于 AXI 支持乱序发送，乱序发送需要主机的 ID 信号支撑，而不同的主机发送的 ID 可能相同，而 AXI Interconnect 解决了这一问题，**他会对不同主机的 ID 信号进行处理让 ID 变得唯一。**

**AXI 握手协议：**

AXI4 所采用的是一种 READY，VALID 握手通信机制，简单来说主从双方进行数据通信前，有一个握手的过程。传输源产生 VLAID 信号来指明何时数据或控制信息有效。

而目地源产生 READY 信号来指明已经准备好接受数据或控制信息。 传输发生在 VALID 和 READY 信号同时为高的时候。

突发传输中利用last信号进行表示传输结束。