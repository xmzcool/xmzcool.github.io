---
layout:     post
title:      FPGA面试题准备
subtitle:   网上资料汇总
date:       2020-04-7
author:     MZ
header-img: img/post-bg-FPGAPrepare.jpg
catalog: true
tags:
    - work prepare
---

# FPGA面试题准备

> 网上搜了几篇FPGA面试题，特此总结如下。
>
> https://www.jianshu.com/p/8e99e396e0f3
>
> https://blog.csdn.net/mochenbaobei/article/details/82730726	

## 1. FPGA原理

---

### 1.1 FPGA和CPLD的区别：

FPGA是可编程ASIC（专用集成电路）。

CPLD这种基于乘积项（实际就是与或阵列）的PLD基本都是由EEPROM和Flash工艺制造的，一上电就可以工作，无需其他芯片配合。布线方式是全局的，所以延时可预测。CPLD适合做逻辑设计。而SRAM工艺的FPGA是易失的，因为它们是基于 SRAM 工艺的，掉电丢失配置。

|          |         CPLD         |         FPGA          |
| :------: | :------------------: | :-------------------: |
| 内部结构 | Product－term 乘积项 | Look－up Table 查找表 |
| 程序存储 |      内部EEPROM      |   SRAM，外挂EEPROM    |
| 资源类型 |   组合电路资源丰富   |    触发器资源丰富     |
| 使用场合 |    算法和组合逻辑    |       时序逻辑        |
|   速度   |          慢          |          快           |
| 其他资源 |          -           |  PLL、RAM和乘法器等   |
|  保密性  |        可加密        |     一般不能保密      |

### 1.2 FPGA的构成？查找表LUT的原理与结构：

zynq中为28nm的Artix-7，其中每个CLB包含2个slice（ 或1个Slice和1个slicem），每个slice包含4个6输入LUT，8个FF，3个Multiplexer组成；Slicem用LUTs作为专属RAM【1LUT=64*1】或者移位寄存器SRL【1LUT=32bit SRL】。

查找表（look-up-table）简称为LUT，LUT本质上就是一个RAM。这也是为什么FPGA需要外接一个ROM来上电配置。 当用户通过原理图或HDL语言描述了一个逻辑电路以后，FPGA开发软件会自动计算逻辑电路的所有可能的结果，并把结果事先写入RAM,这样，每输入一个信号进行逻辑运算就等于输入一个地址进行查表，找出地址对应的内容，然后输出即可。

其组成部分主要有可编程输入/输出单元、基本可编程逻辑单元、嵌入式块RAM、丰富的布线资源、底层嵌入功能单元、内嵌专用硬核等。

1)可编程输入输出单元（IOB）
可编程输入/输出单元简称I/O单元，是芯片与外界电路的接口部分，完成不同电气特性下对输入/输出信号的驱动与匹配要求。FPGA内的I/O按组分类，每组都能够独立地支持
不同的I/O标准。通过软件的灵活配置，可适配不同的电气标准与I/O物理特性，可以调整驱动电流的大小，可以改变上、下拉电阻。目前，I/O口的频率也越来越高，一些高端的 FPGA，通过DDR寄存器技术可以支持高达2Gbps的数据速率。为了便于管理和适应多种电器标准，FPGA的IOB被划分为若干个组（bank），每个 bank的接口标准由其接口电压 VCCO 决定，一个bank只能有一种VCCO，但不同bank的VCCO可以不同。只有相同电气标准的端口才能连接在一起，VCCO电压相同是接口标准的基本条件。

2)可配置逻辑块（CLB）
FPGA的基本可编程逻辑单元是由查找表和寄存器组成的，查找表完成纯组合逻辑功能。FPGA内部寄存器可配置成触发器或锁存器。Altera基本可编程单元LE配置为1寄存器加一个查找表。

3)嵌入式块 RAM（BRAM）
块RAM可被配置为单端口RAM、双端口RAM、内容地址存储器（CAM）以及FIFO等常用存储结构。CAM 存储器在其内部的每个存储单元中都有一个比较逻辑，写入CAM中的数据会和内部的每一个数据进行比较，并返回与端口数据相同的所有数据的地址，因而在路由的地址交换器中有广泛的应用。除了块 RAM，还可以将FPGA中的LUT灵活地配置成RAM、ROM和FIFO等结构。

4)丰富的布线资源
布线资源连通FPGA内部的所有单元，而连线的长度和工艺决定着信号在连线上的驱动能力和传输速度。FPGA芯片内部有着丰富的布线资源，根据工艺、长度、宽度和分布位置的不同而划分为４类不同的类别。第一类是全局布线资源，用于芯片内部全局时钟和全局复位/置位的布线；第二类是长线资源，用以完成芯片Bank间的高速信号和第二全局时钟信号的布线；第三类是短线资源，用于完成基本逻辑单元之间的逻辑互连和布线；第四类是分布式的布线资源，用于专有时钟、复位等控制信号线。

5)底层内嵌功能单元
内嵌功能模块主要指DLL（Delay Locked Loop）、PLL（Phase Locked Loop）、DSP和
CPU等软处理核（Soft Core）。现在越来越丰富的内嵌功能单元，使得单片FPGA成为了系统级的设计工具，使其具备了软硬件联合设计的能力，逐步向SOC平台过渡。

6)内嵌专用硬核
内嵌专用硬核是相对底层嵌入的软核而言的，指FPGA处理能力强大的硬核（Hard Core），等效于ASIC电路。为了提高 FPGA性能，芯片生产商在芯片内部集成了一些专用的硬核。例如：为了提高FPGA的乘法速度，主流的FPGA中都集成了专用乘法器；为了适用通信总线与接口标准，很多高端 FPGA 内部都集成了串并收发器（SERDES），可以达到数十Gbps的收发速度。

### 1.3 FPGA设计流程：

- 功能定义，器件选型
- 设计输入
- 功能仿真(前仿真)ModelSim
- 综合优化
- 布线
- 时序仿真(后仿真)

### 1.4 FPGA芯片内存储器资源：

FPGA芯片内有两种存储器资源：一种叫block ram,另一种是由LUT配置成的内部存储器（也就是分布式ram）。
 Block ram由一定数量固定大小的存储块构成的，使用Block ram资源不占用额外的逻辑资源，并且速度快。但是使用的时候消耗的Block ram资源是其块大小的整数倍。

FPGA中可以综合实现为RAM/ROM/CAM的三种资源：block ram ;触发器（FF），查找表（LUT）；

注意事项：

 1：在生成RAM等存储单元时，应该首选block ram 资源；其原因有二： 第一：使用block ram等资源，可以节约更多的FF和6-LUT等底层可编程单元。使用block ram可以说是“不用白不用”，是最大程度发挥器件效能，节约成本的一种体现； 第二：block ram是一种可以配置的硬件结构，其可靠性和速度与用LUT和register构建的存储器更有优势。

 2：弄清FPGA的硬件结构，合理使用block ram资源；

 3：分析block ram容量，高效使用block ram资源；

 4：分布式ram资源（distribute ram）

### 1.5 FPGA上电方式：

上电——>清空寄存器——>根据M[1:0]电平设置载入模式——> 配置同步 ——> 启动序列 ——>CRC校验 ——> 载入配置文件 ——> 检测器件ID

- JTAG 边界扫描模式 4线
   JTAG 引脚：测试数据输入（TDI）模式选择（TMS）和测试时钟（TCK），TDO输出。在这种模式下，每个 TCK 载入一个比特的数据。JTAG时钟频率—TCK 最高是 33 MHz。
   TMS、TCK 和 TDI 引脚在缺省的情形下都提供了内部的可编程的弱上拉。TDO 是浮空的。
- 从并模式
- 主串模式 `Master Serial` `SPI FLASH`
- 从串模式 好像区别在于是不是自己的时钟CCLK驱动

PROM配置：bit文件 iMPACT转mcs，写入PROM。

上电里面核心电压`VCCINT`先启动，然后是IO电压，，载入模式确定之后进行识别和载入配置文件，需要考虑上电时IO电压为弱上拉，要加入上下拉电阻，改变器件加电顺序等来尽量避免或减少FPGA配置时对电路其他器件的影响。载入成功后还会校验。

配置E²prom eletric eraser program
 IIC总线，要上拉，上电后写一个数据到 EEPROM 的地址 0, 再读出地址 0 的内容。这里我们写的数据是 0x12, 用户可以自行修改。

## 2. 建立时间与保持时间、触发器、亚稳态

---

### 2.1 锁存器（latch）、触发器（flip-flop）、寄存器（Register）的区别：

* 锁存器**电平触发**。用于不同时钟之间的信号同步。`OUT ≈ EN ? IN : no change`latch只要输入信号电平变化，输出就会按照一定逻辑变化（D锁存器输出对输入是透明的）。latch属于异步电路设计，往往会导致时序分析困难,容易引入竞争，不适当的应用latch会大量浪费芯片资源。

* 触发器**边沿触发**。简称FF，双稳态触发器。可以理解为是两个不同电平敏感的锁存器串连而成。前一个锁存器决定了触发器的建立时间，后一个锁存器则决定了保持时间。
* 寄存器通常是指能够用来存储一组二进制代码的同步时序逻辑电路,Flip-flop是register的基本构成单位（一个触发器存一位数据）。register 在同一时钟边沿触发下动作，符合同步电路的设计思想。图为4位寄存器电路结构。

**应避免使用锁存器，尽量使用触发器的原因:**

 1、latch容易产生毛刺，对输入电平敏感，受布线延迟影响大

 2、在FPGA的资源中没有标准latch，但有FF，所以需要用一个逻辑门和ff来组成锁存器，这样就浪费了资源。

 3、latch会让时序十分复杂。没有时钟端

**如何避免偶然生成锁存器？**

如果有的输入没有对应明确的输出，系统会综合出latch。比如没有写else，没有写default。还可以用fullcase语句等等。

PS:不支持always的边沿触发和条件触发同时用，就是说不能一个是always @（a， negedge b）

### 2.2 建立时间与保持时间的概念？

* 建立时间：触发器在时钟上升沿到来之前，其数据输入端的数据必须保持不变的时间。

* 保持时间：触发器在时钟上升沿到来之后，其数据输入端的数据必须保持不变的时间。

![G2DD1S.png](https://s1.ax1x.com/2020/04/07/G2DD1S.png)

### 2.3 为什么触发器要满足建立时间和保持时间？

从物理层面来讲，需要建立时间是因为触发器的D端像一个锁存器在接受数据，前级门的状态需要一段稳定时间；需要保持时间是因为在时钟沿到来之后，触发器要通过反馈来锁存状态，从后级门传到前级门需要时间。

从后果层面讲，如果不满足建立和保持时间，触发器将进入亚稳态，而且0-1中间电压会使亚稳态向后级电路传播。

### 2.4 经典例题

**经典例题1：**时钟周期为T，触发器D1的时钟沿到来.至触发器输出Q变化的时间Tco（CLK-Q）最大为T1max,最小为T1min,逻辑组合电路的延迟时间最大为T2max，最小为T2min，问：**触发器D2的建立时间和保持时间应满足什么条件？**

![G2rT8f.png](https://s1.ax1x.com/2020/04/07/G2rT8f.png)

```undefined
T3 setup < T - T1max - T2max
T3 hold  < T1min + T2min
```

D2的建立时间应该满足： Tco + T2+ T3 setup ＜ T；
D2的保持时间——在时钟沿到来后，D2 in保持旧数据不变的时间，所以时钟到来后（T1+T2）时，D2 in发生变化，T1+T2 应该必须大于D2hold。

**经典例题2：**已知reg的setup，hold时间，求中间组合逻辑的delay范围？

```undefined
  Delay < period - setup – hold
```

### 2.5 如何计算周期T与设计频率（最大频率）Fmax？

周期约束是一个基本时序和综合约束，它附加在时钟网线上，时序分析工具根据PERIOD约束检查时钟域内所有同步元件的时序是否满足要求。

![G2yONn.png](https://s1.ax1x.com/2020/04/07/G2yONn.png)

时钟的最小周期为：

```undefined
TCLK = TCKO + TLOGIC + TNET + TSU－TCLK_SKEW
TCLK_SKEW = TCD2 －TCD1
Fmax = 1/ TCLK;
```

其中TCKO为触发器输出时间，TLOGIC为同步元件之间的组合逻辑延迟，TNET为布线延迟，TSU为同步元件的建立时间，TCLK_SKEW为时钟信号TCD2和TCD1延迟的差别。

### 2.6 建立时间，保持时间不满足怎么处理？

1，降低时钟频率； 2，更换更好器件
Setup time不满足：减少组合逻辑时间，或分开做成流水线
Hold time 不满足：好像没办法

### 2.7 什么是亚稳态？

**亚稳态**是指触发器无法在某个规定的时间段内到达一个可以确认的状态。
进入亚稳态后触发器的输出将不稳定，在0和1之间乱飘，这时需要经过一个恢复时间(决断时间Tmet），其输出才能稳定，但稳定后的值是随机的，与输入无关。而只要有异步设计，亚稳态就是无法避免的。

![G2cnGq.png](https://s1.ax1x.com/2020/04/07/G2cnGq.png)

这就是**为什么要用两级触发器来同步异步输入信号**，
使用两级触发器来使异步电路同步化的电路其实叫做“一步同位器”，但只能用来对一位异步信号进行同步。

### 2.8 有关两级触发器进行一步时钟域同步：

两级触发器可防止亚稳态传播的原理：

![G2cwQK.png](https://s1.ax1x.com/2020/04/07/G2cwQK.png)

假设第一级触发器的输入不满足其建立保持时间，它在第一个脉冲沿到来后输出的数据就为亚稳态，那么在下一个脉冲沿到来之前，其输出的亚稳态数据在一段恢复时间后必须稳定下来，而且稳定的数据必须满足第二级触发器的建立时间，如果都满足了，在下一个脉冲沿到来时，第二级触发器将不会出现亚稳态，因为其输入端的数据满足其建立保持时间。同步器有效的条件：第一级触发器进入亚稳态后的恢复时间 + 第二级触发器的建立时间 < = 时钟周期。
更确切地说，输入脉冲宽度必须大于同步时钟周期与第一级触发器所需的保持时间之和。最保险的脉冲宽度是两倍同步时钟周期。所以，这样的同步电路对于从较慢的时钟域来的异步信号进入较快的时钟域比较有效，对于进入一个较慢的时钟域，可能根本采不到异步信号。
**但是**一级FF稳定后的out是随机的，到第二级FF后大概率没有亚稳态了，但是得到的数据0/1都有可能，仅适用于对错误不敏感的地方。对于敏感的电路，可以采用双口RAN或FIFO同步。

[亚稳态处理](https://link.jianshu.com/?t=http://blog.csdn.net/gududeyhc/article/details/8795153)

### 2.9 如何防止亚稳态？

1.降低系统时钟频率，增大T

2.用反应更快的FF（Tsu和Th更小）

3.改善时钟质量，用边沿变化快速的时钟信号

消除：

1.异步输入采样2次以上再给内部模块使用（最简单可靠的一位同步器）

2.用FIFO对跨时钟域数据进行缓冲设计

3.复位电路采用异步复位，同步释放处理

**例：异步复位与同步复位：**

同步复位： 必须保证复位电平维持时间大于clk间隔时间

```verilog
always @(posedge clk)
    begin
       if(!rst_n) a <= 1'b0;
       else       a <= b;
    end
```

异步复位：需要同步释放。采用第二级寄存器输出作为**全局复位信号输出**。always @ (posedge clk or negedge reset)

```verilog
wire        sys_rst_n;  
reg [1:0]   rst_r;  

always @(posedge clk or negedge rst_n)  
begin   
    if(!rst_n)  rst_r <= 2'd0;
    else        rst_r <= {rst_r[0], 1'b1};  
end
assign  sys_rst_n = rst_r[1];
```

[参考博客](https://link.jianshu.com/?t=http://www.cnblogs.com/linjie-swust/archive/2012/01/07/ywt.html)

## 3. 同步与异步，FIFO：

---

## 3.1 同步电路与异步电路：

**同步时序电路**：用各种**触发器**实现，主要信号与OUT都是**一个时钟沿经过各种触发器触发**的。所以只有时钟脉冲到来才能改变电路的状态，所以不论IN如何变化，状态表中的每个状态都是稳定的。

**异步时序电路**：用**组合逻辑电路**（与非门）实现，电路中没有统一的时钟，典型的有FIFO/RAM读写信号、地址译码器等。主要信号与OUT**不是某个时钟信号驱动FF产生**的。电路中除可以使用带时钟的触发器外，还可以使用不带时钟的触发器和延迟元件作为存储元件，电路中没有统一的时钟，电路状态的改变由外部输入的变化直接引起。

**核心区别**在于是否所有触发器都与唯一时钟脉冲同步。always后面是变量还是沿。比如一个触发器的输出连接到另一个触发器的时钟端去触发就是异步。
同步时序很好避免毛刺，异步时序电路的最大缺点是容易产生毛刺。同步电路的问题在于时钟偏差`Clock skew`.
比如a+b=c.如果ab不同步，会有毛刺。
PS：阻塞赋值生成组合逻辑，非阻塞生成时序逻辑。

### 3.2 多时钟域设计中，不同时钟域数据如何交换？

不同的时钟域之间信号通信时需要进行同步处理，这样可以防止新时钟域中第一级触发器的亚稳态信号对下级逻辑造成影响。

* 当单个信号跨时钟域时，可以采用两级触发器（一位同步器）来同步；

* 数据流或地址总线跨时钟域时可以采用异步FIFO（或双口RAM）来实现时钟同步；

* 多位数据可以采用保持寄存器加握手信号的方法（多数据，控制信号，地址信号）。

### 3.3 同步时序电路&异步时序电路 如何实现延时？

异步电路一般是通过插入1个buffer、两级非门等，但这是不适合同步电路实现延时的。

在同步电路中的延时，一般通过时序控制实现，作为电路逻辑进行设计。

 1）对于比较大的和特殊要求的延时，一般通过高速时钟产生计数器，通过计数器来控制延时；

 2）对于比较小的延时，可以通过D触发器打一拍，延时了一个时钟周期，而且完成了信号与时钟的初次同步，在输入信号采样和增加时序约束余量中使用。

像#5 这种语句是“行为级代码描述”，仿真可以，电路综合会被忽略。

### 3.4 非同源时钟如何同步化？

当系统中有两个或两个以上非同源时钟的时候，数据的建立和保持时间很难得到保证。

我们可以使用带使能端的 D 触发器，并引入一个高频时钟（频率高于系统中的所有源时钟） ，便可以达到使系统中所有源时钟同步的效果。

**例：系统时钟设计：**

系统有两个不同源时钟，一个为 3MHz，一个为 5MHz，不同的触发器使用不同的时钟。为了使系统稳定，假设我们引入一个 20MHz 时钟，那么这个 20MHz 的时钟怎么才能将 3M和 5M 时钟同步化呢？

20M 的高频时钟将作为系统时钟，输入到所有触发器的的时钟端。3M_EN 和 5M_EN将控制所有触发器的使能端。即原来接 3M 时钟的触发器，接 20M 时钟，同时 3M_EN 将控制该触发器使能，原接 5M 时钟的触发器，也接 20M 时钟，同时 5M_EN 将控制该触发器使能。这样我们就可以将任何非同源时钟同步化。

异步信号输入总是无法满足数据的建立保持时间， 所以建议大家把所有异步输入都先经过**双触发器**进行同步化。

### 3.5 FIFO问题：

[深入理解FIFO](https://link.jianshu.com?t=http://blog.csdn.net/houqi02/article/details/51683635)

FIFO`First In First Out`是一种先进先出的数据缓存器，与普通存储器的区别是**没有外部读写地址线**，这样使用起来非常简单，但缺点就是只能顺序写入数据，顺序的读出数据， **其数据地址由内部读写指针自动加1完成**，不能像普通存储器那样可以由地址线决定读取或写入某个指定的地址。

FIFO一般用于不同时钟域之间的数据传输，或不同宽度的数据接口相连。根据FIFO读写时钟域是否相同，可以将FIFO分为同步FIFO和异步FIFO。

FIFO的常见参数：

- 宽度：即FIFO一次读写操作的数据位；
- 深度：指的是FIFO可以存储多少个N位的数据（如果宽度为N）。
- 满标志：FIFO已满或将要满时由FIFO的状态电路送出的一个信号，以阻止FIFO的写操作继续向FIFO中写数据而造成溢出（overflow）。
- 空标志：FIFO已空或将要空时由FIFO的状态电路送出的一个信号，以阻止FIFO的读操作继续从FIFO中读出数据而造成无效数据的读出（underflow）。
- 读时钟，写时钟
- 写指针：总是指向下一个**将要被**写入的单元，复位时，指向第1个单元(编号为0)
- 读指针：总是指向当前要被读出的数据，复位时，指向第1个单元(编号为0)

**FIFO设计的难点在于怎样判断FIFO的空/满状态。异步FIFO需要解决跨时钟域传递**为了保证数据正确的写入或读出，而不发生溢出或读空的状态出现，必须保证FIFO在满的情况下，不能进行写操作。在空的状态下不能进行读操作。怎样判断FIFO的满/空就成了FIFO设计的核心问题。

**空/满检测：当读写指针相等时~**

- FIFO 空：如果是复位或读操作引起（当读指针读出FIFO中最后一个字后，追赶上了写指针时)
- FIFO 满：如果是写操作引起（当写指针转了一圈，折回来又追上了读指针）
- 还可以用多加一位extra bit来记录折回，如果extra也一样代表空，不一样代表写满

在指针中添加一个额外的位(extra bit)，当写指针增加并越过最后一个FIFO地址时，就将写指针这个未用的MSB加1，其它位回零。对读指针也进行同样的操作。此时，对于深度为2n的FIFO，需要的读/写指针位宽为(n+1)位，如对于深度为8的FIFO，需要采用4bit的计数器，0000～1000、1001～1111，MSB作为折回标志位，而低3位作为地址指针。

- 如果两个指针的MSB不同，说明写指针比读指针多折回了一次；如r_addr=0000,而w_addr = 1000,为满。
- 如果两个指针的MSB相同，则说明两个指针折回的次数相等。其余位相等，说明FIFO为空；

写操作无条件清除空标志；读操作无条件清除满标志。

而异步FIFO不同时间域，**将指针同步到其它时钟域时，用两级FF传递格雷码地址防止亚稳态**，gray码可以保证即使亚稳态数据不准，也能正确判断空满，需要一个always块专门进行bin2gray的转换。gray码每次只变一个寄存器一位，这样仅仅1bit可能产生亚稳态。采错最多错到上一位去，不会有影响。

[异步FIFO为什么用格雷码](https://www.cnblogs.com/kxk_kxk/p/3931591.html)

**6个模块实现：**顶层；双口RAM；2个跨域同步指针模块；空判断逻辑；满判断逻辑；

[![G7Irct.png](https://s1.ax1x.com/2020/04/11/G7Irct.png)](https://imgchr.com/i/G7Irct)

根据异步FIFO的设计架构，归纳以下设计步骤：
写时钟域：
 （1）根据写使能wr_en和写满标志位wr_full产生二进制写指针
 （2）根据二进制写指针产生双端口RAM的写地址
 （3）由二进制写指针转换成格雷码写指针
 （4）对格雷码读指针在写时钟域中进行两级同步得同步后格雷码读指针
 （5）同步后格雷码读指针转化成同步后二进制读指针
 （6）步骤（3）与步骤（4）比较得写满标志位wr_full
 （7）步骤（1）与步骤（5）相减得指示写FIFO的数据量
读时钟域：
 （8）根据读使能rd_en和读空标志位rd_empty产生二进制读指针
 （9）根据二进制读指针产生双端口RAM的读地址
 （10）由二进制读指针转换成格雷码读指针
 （11）对格雷码写指针在读时钟域中进行两级同步得同步后格雷码写指针
 （12）同步后格雷码写指针转化成同步后二进制写指针
 （13）步骤（10）与步骤（11）比较得读空标志位rd_empty
 （14）步骤（8）与步骤（12）相减得指示读FIFO的数据量

关键代码：

```verilog
reg[DATA_SIZE-1:0] mem_name[RAM_Depth-1:0]; //RAM深度=2^ADDR_WIDTH
assign rdata =  Mem[raddr];
assign rempty = (rgraynext == rq2_wptr);    //指针是否相等
assign wfull  = (wgraynext == {~wq2_rptr[ADDRSIZE:ADDRSIZE-1],wq2_rptr[ADDRSIZE-2:0]}); //  ??
```

[[1\]异步fifo的verilog实现](https://link.jianshu.com/?t=http://www.cnblogs.com/BitArt/archive/2013/04/10/3010073.html)
[[2\]步骤参考](https://link.jianshu.com/?t=http://blog.chinaaet.com/crazybird/p/5100000872)
[[3\] 三种同步FIFO的实现方法（verilog实现）](https://link.jianshu.com/?t=http://blog.csdn.net/limanjihe/article/details/49910557)

**例：用verilog/vhdl写一个fifo控制器(包括空，满，半满信号)？**

八个always模块实现，两个用于读写FIFO，两个用于产生头地址head和尾地址tail，一个产生counter计数，剩下三个根据counter的值产生空，满，半满信号产生空，满，半满信号。

**例：用系统任务$readmemb初始化memory.mem:**

```verilog
reg[DATA_SIZE-1:0] mem_name[RAM_Depth-1:0]; //RAM深度=2^ADDR_WIDTH
$readmemb("init.dat",mem_name)
```









## 3.时序设计的实质：

电路设计的难点在时序设计，时序设计的实质就是满足每一个触发器的建立/保持时间的而要求。

## 6.什么是亚稳态？为什么两级触发器可以防止亚稳态传播？

亚稳态是指触发器无法再某个规定时间段内到达一个可以确认的状态。使用两级触发器来使异步电路同步化的电路实际叫做“一步同位器”，它只能用来对一位异步信号进行同步。

两级触发器可防止亚稳态传播的原理：假设第一级触发器的输入不满足其建立/保持时间，它在第一个脉冲恢复时间后必须稳定下来，而且稳定的数据必须满足第二级触发器的建立时间，如果都满足了，在下一个脉冲沿到来时第二级触发器将不会出现亚稳态，因为其输入端的数据满足其建立保持时间。

同步器有效的条件：第一级触发器进入亚稳态后的恢复时间+第二级触发器的建立时间<=时钟周期。更确切地说，输入脉冲宽度必须大于同步时钟周期与第一级触发器所需的保持时间之和。最保险的脉冲宽度是两倍同步时钟周期。所以，这样的同步电路对于从较慢的时钟域来的异步信号进入较快的时钟域比较有效，对于进入一个较慢的时钟域，则没什么作用。

**但是**一级FF稳定后的out是随机的，到第二级FF后大概率没有亚稳态了，但是得到的数据0/1都有可能，仅适用于对错误不敏感的地方。对于敏感的电路，可以采用双口RAN或FIFO同步。

## 7.系统最高速度计算（最快时钟频率）和流水线设计思想：

同步电路的速度是指同步系统时钟的速度，同步时钟越快，电路处理数据的时间间隔越短，电路在单位时间内处理的数据量就越大。

假设Tco是触发器的输入数据被打到触发器到数据到达触发器输出端的延时时间；Tdelay是组合逻辑的延时；Tsetup是D触发器的建立时间。假设数据已被时钟打入D触发器，那么数据到达第一个触发器的Q输入端需要的延时是Tco，经过组合逻辑Tdelay，然后到达第二个触发器D端，要希望时钟能在第二个触发器再次被稳定地打入D触发器，则时钟的延迟必须大于Tco+Tdelay+Tsetup，也就是说最小的时钟周期Tmin = Tco+Tdelay+Tsetup，即最快的时钟频率Fmax = 1/Tmin。

FPGA 开发软件也是通过这种方法来计算系 统最高运行速度 Fmax。因为 Tco 和Tsetup 是由具体的器件工艺决定的，故设计电路 时只能改变组合逻辑的延迟时间 Tdelay，所以说缩短触发器间组合逻辑的延时时间是 提高同步电路速度的关键所在。

而要使电路稳定工作，时钟周期必须满足最大延时要求。故只有缩短最长延时路径，才能提高电路的工作频率。可以将较大的组合逻辑分解为较小的N块，通过适当的方法平均分配组合逻辑，然后在中间插入触发器，并和原触发器使用相同的时钟，就可以避免在两个触发器之间 出现过大的延时，消除速度瓶颈，这样可以提高电路的工作频率。

这就是所谓"流水线"技术的基本设计思想，即原设计速度受限部分用一个时钟周期实现，采用流水线技术插入触发器后，可用N个时钟周期实现，因此系统的工作速度可以加快，吞吐量加大。注意，流水线设计会在原数据通路上加入延时，另外硬件面积也会稍有增加。

## 8.时序约束的概念和基本策略？

时序约束主要包括周期约束，偏移约束，静态时序路径约束三种。通过附加时序约束可以综合布线工具调整映射和布局布线，使设计达到时序要求。附加时序约束的一般策略是先附加全局约束，然后对快速和慢速例外路径附加专门约束。附加全局约束时，首先定义设计的所有时钟，对各时钟域内的同步元件进行分组，对分组附加周期约束，然后对FPGA/CPLD输入输出PAD附加偏移约束、对全组合逻辑的PAD TO PAD路径附加约束。附加专门约束时，首先约束分组之间的路径，然后约束快、慢速例外路径和多周期路径，以及其他特殊路径。

## 9.附加约束的作用？

1：提高设计的工作频率（减少了逻辑和布线延时）；

2：获得正确的时序分析报告；（静态时序分析工具以约束作为判断时序是否满足设计要 求的标准，因此要求设计者正确输入约束，以便静态时序分析工具可以正确的输出时序 报告）。

3：指定FPGA/CPLD的电气标准和引脚位置。

## 10.FPGA设计工程师努力的方向：

SOPC，高速串行I/O，低功耗，可靠性，可测试性和设计验证流程的优化等方面。随着芯片工艺的提高，芯片容量、集成度都在增加，FPGA 设计也朝着高速、高度集成、 低功耗、高可靠性、高可测、可验证性发展。芯片可测、可验证，正在成为复杂设计所 必备的条件，尽量在上板之前查出 bug，将发现 bug 的时间提前，这也是一些公司花 大力气设计仿真平台的原因。另外随着单板功能的提高、成本的压力，低功耗也逐渐进入FPGA设计者的考虑范围，完成相同的功能下，考虑如何能够使芯片的功耗最低， 据说 altera、xilinx 都在根据自己的芯片特点整理如何降低功耗的文档。高速串行IO的应用，也丰富了FPGA 的应用范围，象 xilinx的v2pro中的高速链路也逐渐被应用。总之，学无止境，当掌握一定概念、方法之后，就要开始考虑FPGA其它方面的问题了。

## 11.对于多位的异步信号如何进行同步？

对以一位的异步信号可以使用“一位同步器进行同步”，而对于多位的异步信号，可以采用如下方法：

1：可以采用保持寄存器加握手信号的方法（多数据，控制，地址）；

2：特殊的具体应用电路结构,根据应用的不同而不同 ；

3：异步FIFO。（最常用的缓存单元是DPRAM）

## 12.锁存器（latch）和触发器（flip-flop）区别：

电平敏感的存储器件称为锁存器。可分为高电平锁存器和低电平锁存器，用于不同时钟之间的信号同步。有交叉耦合的门构成的双稳态的存储原件称为触发器。分为上升沿触发和下降沿触发。可以认为是两个不同电平敏感的锁存器串连而成。前一个锁存器决定了触发器的建立时间，后一个锁存器则决定了保持时间。

## 14.什么是时钟抖动？

时钟抖动是指芯片的某一个给定点上时钟周期发生暂时性变化，也就是说时钟周期在不同的周期上可能加长或缩短。它是一个平均值为0的平均量。

## 15.FPGA设计中对时钟的使用？

FPGA 芯片有固定的时钟路由，这些路由能有效减少时钟抖动和偏差。需要对时钟进行相位移动或变频的时候，一般不允许对时钟进行逻辑操作，这样不仅会增加时钟的偏差和抖动，还会使时钟带上毛刺。一般的处理方法是采用FPGA芯片自带的时钟管理器如PLL,DLL或DCM，或者把逻辑转换到触发器的 D输入（这些也是对时钟逻辑操作的替代方案）。

## 16.FPGA设计中如何实现同步时序电路的延时？

首先说说异步电路的延时实现：异步电路一半是通过加 buffer、两级与非门等（我还没用过所以也不是很清楚），但这是不适合同步电路实现延时的。在同步电路中，对于比 较大的和特殊要求的延时，一半通过高速时钟产生计数器，通过计数器来控制延时；对于比较小的延时，可以通过触发器打一拍，不过这样只能延迟一个时钟周期。

## 17.FPGA中可以综合实现为RAM/ROM/CAM的三种资源及其注意事项：

三种资源：block ram；触发器（FF），查找表（LUT）。

注意事项：

1)在生成RAM等存储单元时，应该首选block ram资源；其原因有二：第一：使用block ram等资源，可以节约更多的FF和4-LUT等底层可编程单元。使用 block ram可以说是“不用白不用”，是最大程度发挥器件效能，节约成本的一种体现；第二：block ram是一种可以配置的硬件结构，其可靠性和速度与用LUT和register构建的存储器更有优势。

2)弄清FPGA的硬件结构，合理使用block ram资源；

3)分析block ram容量，高效使用block ram资源；

4)分布式ram资源（distribute ram）

## 18.什么是“线与”逻辑，要实现它，在硬件特性上有什么具体要求？

线与逻辑是两个输出信号相连可以实现与的功能。在硬件上,要用oc门来实现,由于不用oc门可能使灌电流过大,而烧坏逻辑门. 同时在输出端口应加一个上拉电阻。Oc门就是集电极开路门。

## 19.什么是竞争与冒险现象？怎样判断？如何消除？

在组合电路中，某一输入变量经过不同途径传输后，到达电路中某一汇合点的时间有先有后，这种现象称竞争；由于竞争而使电路输出发生瞬时错误的现象叫做冒险。（也就是由于竞争产生的毛刺叫做冒险）。

判断方法：代数法（如果布尔式中有相反的信号则 可能产生竞争和冒险现象）；卡诺图：有两个相切的卡诺圈并且相切处没有被其他卡诺圈包围，就有可能出现竞争冒险；实验法：示波器观测；

解决方法：1：加滤波电路，消除毛刺的影响；2：加选通信号，避开毛刺；3：增加冗余项消除逻辑冒险。

## 20.用Verilog设计一个5分频器：

```Verilog
module divfreq
    (input 			clk, 
     output 		clk1x, 
     input 			rst, 
     output			clk1xpose, 
     output			clk1xnege, 
     output	[2:0]	coutpose, 
     output	[2:0]	coutnege);
    
    parameter div1 = 2, div2 = 4;
    
    assign clk1x = clk1xpose | clk1xnege;
    
    always@(posedge clk or negedge rst)
    begin
        if(!rst)
            clk1xpose = 0
        else if(coutpose == div1)
          	clk1xnege = ~clk1xnege;
        else if(coutnege == div2)
            clk1xnege = ~clk1xnege;  
        else
            clk1xnege = clk1xnege;
    end
    always@(posedge clk or negedge rst)
	begin
		if(!rst)
			coutpose = 0;
		else if(coutpose == div2)
			coutpose = 0;
		else
			coutpose = coutpose + 1;
	end
	always@(negedge clk or negedge rst)
	begin
		if(!rst)
			coutnege = 0;
		else if(coutnege == div2)
			coutnege = 0;
		else
            coutnege = coutnege + 1;
		end
endmodule

```

## 21.用状态机检测序列为11001101，输出为1，否则输出为0：

```verilog
module machine_test2(clk,rst,din,dout);
	input clk,rst;
	input din;
	output dout;
	//11001101
	parameter 	idle=0,
				st0=1,
				st1=2,
				st2=3,
				st3=4,
				st4=5,
				st5=6,
				st6=7,
				st7=8;
	reg [3:0] current_state,next_state;
	reg dout;
	always @ (posedge clk or negedge rst)
	begin
		if(!rst)
			current_state<=idle;
		else
			current_state<=next_state;
		end
	always @ (next_state or current_state or din or 	dout)
    begin
        case(current_state)
		idle:
			if(din)
				next_state=st0;
			else
				next_state=idle;
		st0:
			if(din)
				next_state=st1;
			else
				next_state=idle;
        st1:
			if(!din)
				next_state=st2;
        	else
				next_state=st1;
		st2:
			if(!din)
				next_state=st3;
			else
				next_state=st0;
		st3:
			if(din)
				next_state=st4;
			else
				next_state=idle;
		st4:
			if(din)
				next_state=st5;
			else
				next_state=idle;
		st5:
			if(!din)
				next_state=st6;
			else
				next_state=st1;
		st6:
			if(din)
				next_state=st7;
			else
				next_state=st3;
		st7:
			if(din)
				next_state=st1;
			else
				next_state=idle;
        default:
			next_state=idle;
		endcase
	end
	always @ (posedge clk)
	begin
		if(next_statest7)
			dout<=1’d1;
		else
			dout<=1’d0;
	end
endmodule

```

## 22. IC设计中同步复位与异步复位的区别：

异步复位是不受时钟影响的，需要一个全局的信号来对整个芯片进行整体的复位，到一个初始的确定状态。

而同步复位需要在时钟沿来临的时候才会对整个系统进行复位。

使用FPGA设计时芯片的异步复位必须要走全局网络。异步复位最大的优点是, 数据通路就可以不依赖于时钟而确保清洁可控。然而, 异步复位 STA (静态时序分析) 的复杂性要高于同步复位设计; 如果异步复位信号在触发器时钟有效沿附近“释放”(复位信号从有效变为无效) 的话, 可能会导致触发器输出的亚稳态。

## 23.MOORE 与 MEELEY 状态机的特征

Moore有限状态机输出只与当前状态有关，与输入信号的当前值无关。在时钟脉冲的有效边沿作用后的有限个门延后，输出达到稳定值。从时序上看，Moore状态机属于同步输出状态机。Moore有限状态机最重要的特点就是将输入与输出信号隔离开来。
Mealy状态机的输出是现态和所有输入的函数，随输入变化而随时发生变化。从时序上看，Mealy 状态机属于异步输出状态机，它不依赖于时钟。

## 25.程序下载到FPGA的方式有哪几种，JTAG有哪几条线：

JTAG：下载sof文件，掉电丢失。可以将sof转换为jic文件，用EPCSx配置，掉电不丢失。

AS：下载pof文件，配置EPCSx，掉电不丢失。

PS：由外部计算机或控制器控制配置过程。

JTAG 有以下几条线：

TCK：测试时钟输入，用于移位控制，上升沿将测试指令、测试数据和控制输入信号移入芯片；下降沿时将数据从芯片移出。

TMS：测试模式选择，串行输入端，用于控制芯片内部的JTAG状态机。

TDI：测试数据输入，串行输入端，用于指令和编程数据的输入，在时钟上升沿，数据被捕获。

TDO：测试数据输出，串行输出端，时钟下降沿，数据被驱动输出。

TRST：测试复位输入（仅用于扩展 JTAG），异步、低电平有效，用于 JTAG 初始化时。

## 26.时钟周期为 T，触发器 D1 的建立时间最大为T1max，最小为T1min。组合逻辑电路最大延迟为T2max，最小为T2min。问：触发器 D2 的建立时间 T3 和保持时间 T4 应满足什么条件？

![GgNPln.png](https://s1.ax1x.com/2020/04/07/GgNPln.png)

T3 <= T - T2max

![GgNAmV.png](https://s1.ax1x.com/2020/04/07/GgNAmV.png)

T4 <= T2min

## 27.你知道哪些常用的逻辑电平？TTL与CMOS电平可以直接互联么？

常用逻辑电平:12V,5V,3.3V;

TTL和CMOS不可以直接互连,由于TTL是在0.3-3.6V之间,而 CMOS则是有在12V的有在5V的.CMOS输出接到TTL是可以直接互连.TTL接到CMOS 需要在输出端口加一上拉电阻接到5V或者12V.

## 28.给了reg的setup，hold时间，求中间组合逻辑的delay范围

Delay < period - setup – hold