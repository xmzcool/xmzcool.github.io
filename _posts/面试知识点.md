---
layout:     post
title:      学习笔记：FPGA设计常见知识点
subtitle:   Learning Notes
date:       2020-08-17
author:     MZ
header-img: img/post-bg-mianshixiangguan.jpg
catalog: true
tags:
    - Learning Notes

---

# FPGA设计常见知识点

> 2020.8.17

## 1. 触发器、锁存器、寄存器

> **锁存器（latch）和触发器（filp-flop）的概念和区别？为什么多用register。行为级描述中latch如何产生的？**

1. 锁存器是什么？

   从概念上来讲，锁存器是电平触发的存储单元，数据存储的动作取决于输入时钟（或者使能）信号的电平值。简单而言，锁存器的输入有数据信号和使能信号，**当处于使能状态时，输出随着输入变化而变化，当不处于使能状态时，输入信号怎么变化都不会影响输出**。是时序电路。

2. 触发器是什么？

   触发器是对脉冲边沿敏感的器件，**它的变化只会在时钟的上升沿或者下降沿到来的瞬间改变**，是时序电路。下图是几个典型的触发器：

   ![img](https://mmbiz.qpic.cn/mmbiz_png/RUdmIJpZSdGTKtw2ZZicEhKuN0AG7uB1uACyOHkcKYK8jnrNmhumZQHnl0czXoLzoJVbu73ZX49iaw6qKiaRu77vw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

   D触发器结构：https://blog.csdn.net/fucong59/article/details/83030714。

3. 触发器和锁存器的区别？

   从上面的描述可以看出，锁存器是电平敏感，触发器是边沿触发。那么对于电平触发，当使能时，如果输入信号不稳定，那么输出就会出现**毛刺**，而触发器就不会出现这种问题，他的变化只出现在边沿变化处。如果使用**门电路来搭建Latch和D触发器，则Latch消耗的门资源比D触发器要少**，这是Latch比D触发器优越的地方。所以在ASIC中使用Latch的集成度比D触发器高，但在FPGA中恰好相反，因为FPGA中没有标准的Latch单元，但有D触发器单元，一个Latch需要多个LE才能实现。

4. register是什么？

   register是寄存器，用于暂时存放参与运算的数据和运算结果。在实际的数字系统中，通常把能够用来存储一组二进制代码的同步时序逻辑电路称为寄存器。由于触发器内有记忆功能，因此利用触发器可以方便地构成寄存器。由于一个触发器能够存储一位二进制码，所以把n个触发器的时钟端口连接起来就能构成一个存储n位二进制码的寄存器。

5. 为什么多用register？

   换个角度来讲，为什么少用latch呢？首先，latch是电平触发的，这样就容易产生毛刺；其次，latch属于异步电路，会使STA变得极其复杂；再者latch会浪费硬件资源（对FPGA而言）。因为在FPGA当中，是没有latch单元的，要生成latch单元需要耗费其他资源。

6. latch是如何产生的？

   类wire型：定义成reg，综合时被优化成wire（常见在always组合逻辑中）。

   ①类wire型的数据“自己等于自己”的情况下会产生latch；

   ②类wire型的数据，由于if或者case语句的逻辑表达不完全，会产生latch。

   真正的reg型，如果不在case里面加上default，或者if不加上else，都不会产生latch，在else的情况下，寄存器的值保持不变，其实相当于自动“附加”上“else  test2 <= test2; ”，而reg不用怕“自己等于自己”。

## 2. 跨时钟域信号处理

- **单比特信号做跨时钟域**主要有两种情况，第一种为慢时钟域到快时钟域，第二种为快时钟域到慢时钟域。

  - **慢到快：**在慢时钟域（clk_b）下的脉冲pulse_b在快时钟域（clk_a）看来，是一个很宽的“电平”信号，会保持多个clk_a时钟周期，所以一定能被clk_a采到。经验设计采集过程**必须打两拍**。**第一拍将输入信号同步化**，同步化后的输出可能带来建立/保持时间的冲突，产生亚稳态。**需要再打一拍，减少亚稳态带来的影响**。一般来说两级是最基本要求，如果是高频率设计，则需要增加寄存级数来大幅降低系统的不稳定性。也就是说采用多级触发器来采样来自异步时钟域的信号，级数越多，同步过来的信号越稳定。

    特别需要强调的是，**此时pulse_b必须是clk_b下的寄存器信号**，如果pulse_b是clk_b下的组合逻辑信号，一定要先在clk_b先用D触发器（DFF）抓一拍，再使用两级DFF向clk_a传递。这是因为clk_b下的组合逻辑信号会有毛刺，在clk_b下使用时会由于setup/hold时间保证毛刺不会被clk_b采到，但由于异步相位不确定，组合逻辑的毛刺却极有可能被clk_a采到。代码框架如下：

    ```verilog
    always @ (posedge clk_a or negedge rst_n)
        begin
            if (rst_n == 1'b0) 
                begin
                   pules_a_r1 <= 1'b0;
                   pules_a_r2 <= 1'b0;
                   pules_a_r3 <= 1'b0;
                end
            else 
                begin                                   //打3拍
                   pules_a_r1 <= pulse_b;
                   pules_a_r2 <= pules_a_r1;
                   pules_a_r3 <= pules_a_r2;
                end
        end
     
    assign pulse_a_pos  = pules_a_r2 & (~pules_a_r3);   //上升沿检测
    assign pulse_a_neg  = pules_a_r3 & (~pules_a_r2);   //下降沿检测
    assign pulse_a      = pules_a_r2;
    ```

  - **快到慢：**实际上，电平信号level_a的**宽度足够宽**才能被clk_b采集到才可以保证系统正常工作。那么对于脉冲信号pulse_a采取怎样的处理方法呢？可以用一个展宽信号来替代pulse_a实现垮时钟域的握手。

    主要原理就是先把脉冲信号在clk_a下展宽，再操作，信号图如下：

    <img src="https://mmbiz.qpic.cn/mmbiz_png/RUdmIJpZSdGPYsxIszm4MuhH0CJahXb3hZRo3vUSbJHDavbjMcoqKKvXSzeVlJ7G9OxauhbCvic8JwqmIEJ7Wkw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img" style="zoom:67%;" />

- **多比特数据跨时钟域**方法：

  - 异步FIFO（读写指针用格雷码）或异步双口RAM。

  - 将多比特信号转化为格雷码进行传输。
  - 多比特信号融合：只要有可能，就要将跨时钟域的多比特信号融合到单比特跨时钟域信号。设计中在碰到多比特需要跨时钟域时，可以先考虑是否真的需要多比特来控制逻辑跨越时钟边界?
  - 多周期路径规划：多周期路径规划是指在**传输非同步数据到接收时钟域时配上的一个同步的控制信号**，数据和控制信号被同时发送到接收时钟域，**同时控制信号在接收时钟域使用俩级寄存器同步到接收时钟域**，使用此同步后的控制信号来加载数据，数据可以在目的的寄存器被安全加载。因为**非同步数据传递到接收时钟域并在多个时钟周期内保持稳定，所以数据的传递是安全的，数据值并无陷入亚稳态的危险**。
  - 握手机制：使用握手协议方式处理跨时钟域数据传输时，只需要对双方的握手信号（req 和 ack）分别使用脉冲检测方法进行同步，在具体实现中，假设req ，ack， data，总线在初始化时都处于无效状态，发送域先把数据放入总线，随后发送有效的req信号给接收域；接收域在检测到有效的req信号后锁存数据总线，然后会送一个有效的ack信号表示读取完成应答；发送域在检测到有效ack信号后撤销当前的req信号，接收域在检测到req撤销后也相应撤销ack信号，此时完成一次正常握手通信，此后，发送域可以继续开始下一次握手通信，如此循环，该方式能够使接收到的数据稳定可靠，有效的避免了亚稳态的出现，但是控制信号握手检测会消耗通信双方较多的时间

## 3. 状态机

- **为什么状态量用独热码表示？**

  那就要从每种编码的特性上说起了，首先独热码因为每个状态只有1bit是不同的，所以在执行到state == TWO这条语句时，综合器会识别出这是一个比较器，而因为只有1比特为1，所以**综合器会进行智能优化为（state[2] == 1’b1）**，这就相**当于把之前3比特的比较器变为了1比特的比较器，大大节省了组合逻辑资源**，但是付出的代价就是状态变量的位宽需要的比较多，而我们**FPGA中组合逻辑资源相对较少**，所以比较宝贵，而寄存器资源较多，所以很完美。而二进制编码的情况和独热码刚好相反，他因为使用了较少的状态变量，使之在减少了寄存器状态的同时无法进行比较器部分的优化，所以使用的寄存器资源较少，而使用的组合逻辑资源较多，我们还知道CPLD就是一个组合逻辑资源多而寄存器逻辑资源少的器件，因为这里我们使用的是FPGA器件，所以使用独热码进行编码。就因为这个比较部分的优化，还使得使用**独热码编码的状态机可以在高速系统上运行**，其原因是多比特的比较器每个比特到达比较器的时间可能会因为布局布线的走线长短而导致路径延时的不同，这样在高速系统下，就会导致采集到不稳定的状态，导致比较后的结果产生一个时钟的毛刺，使输出不稳定，而单比特的比较器就不用考虑这种问题。

- **状态转换图画法**

  对于状态机的设计，其重点肯定是状态转移图的设计，如图1所示的例子，每个近似椭圆的框表示一个状态（也可以用其他图形表示），每个状态之间都有一个指向的箭头，表示的是状态跳转的过程，箭头上有标注的一组数字，斜杠（/）**左边表达的是状态的输入，斜杠（/）右边表达的是状态的输出**，结构非常的简单，各状态之间的功能、跳转的条件、输入输出都能够在状态转移图中非常清楚的表达出来。

  <img src="https://mmbiz.qpic.cn/mmbiz_png/RUdmIJpZSdH8icdUO7tiaj0RbeNISxZwacpawuDKhjm9gcjvPQauMBn3EERfEnCF08IticrYwtQibCod5I4bFIaZWg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img" style="zoom:50%;" />

  绘制状态转移图需要知道以下三个要素：

  **①输入：**根据输入可以确定是否需要进行状态跳转以及输出，是影响状态机系统执行过程的重要驱动力；

  **②输出：**根据当前时刻的状态以及输入，是状态机系统最终要执行的动作；

  **③状态：**根据输入和上一状态决定当前时刻所处的状态，是状态机系统执行的一个稳定的过程。

- **moore型和mealy型状态机**

  **mealy状态机的输出不仅与当前状态值有关，而且与当前输入有关；moore状态机的输出仅与当前状态值有关，而与此时的输入无关。**

  下图为mealy型状态机的状态转移图，输出取决于S3状态和输入。

  <img src="https://mmbiz.qpic.cn/mmbiz_png/RUdmIJpZSdH8icdUO7tiaj0RbeNISxZwacSLylrCu4QDb4qeS2A8ljRFkVPJK9MW6HYN8aC1zWRkaaoIib3xXvwHQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img" style="zoom:50%;" />

  下图为moore型状态机的状态转移图，输出只和S4状态有关。

  <img src="https://mmbiz.qpic.cn/mmbiz_png/RUdmIJpZSdH8icdUO7tiaj0RbeNISxZwacl1zyjYiavJLvIdOgmSYz6TtdjoDMCRY07Tnn5qUbTndNfcddAzfqHlQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img" style="zoom:50%;" />

  一句话：Moore状态机的每一状态指定他的输出独立于电路的输入。

## 4. Verilog语法

- **优先级排序**

<img src="https://mmbiz.qpic.cn/mmbiz_png/RUdmIJpZSdGck49HUHETFiacvR1iciafbOXHq4rDCZiaeExg08MuzkmvgvcW6ibhaXiayDOgDbqaSk5sEPy7S1MF3KeA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img" style="zoom:80%;" />

- **逻辑操作**（&举例）

  <img src="/Users/xmz/Library/Application Support/typora-user-images/image-20200826203131008.png" alt="image-20200826203131008" style="zoom:60%;" />

  “&”操作符有两种用途，既可以作为一元操作符(仅有一个操作数)，也可以作为二元操作符(有两个操作数)。当“&”作为**一元**操作符时表示**归约与**。&m是将m中所有比特相与，最后的结果为1bit。例：&4‘b1111 = 1&1&1&1 = 1’b1，&4’b1101 = 1&1&0&1 = 1’b0。

  当“&”作为**二元**操作符时表示**按位与**。m&n是将m的每个比特与n的相应比特相与，在运算的时候要保证m和n的比特数相等，最后的结果和m(n)的比特数相同。例：4’b1010&4’b0101 = 4’b0000，4’b1101&4’b1111= 4’b1101。

  我们在写Verilog代码时常常当if的条件有多个同时满足时就执行使用“&&”**逻辑与**操作符。m &&n是判断m和n是否都为真，最后的结果只有1bit，如果都为真则输出1‘b1，如果不都为真则输出1’b0。要注意和“&”的功能区分。

  此外“&”操作符作为归约与使用时还有妙用。下面是一个分频器，代码结构简单，逻辑也不复杂，就是当计数器计数到15时让输出out取反，相当于实现对sclk的32分频。

  ```verilog
  01module  divider(
  02 input  wire   sclk   ,
  03 input  wire   rst_n  ,
  04
  05 output reg    out
  06);
  07
  08reg[3:0]  cnt;         
  09
  10//cnt
  11always@(posedge   sclk or negedge rst_n)
  12 if(rst_n ==1'b0)
  13     cnt <=4'b0;
  14 else   if(cnt ==4'd15)
  15     cnt <=4'b0;
  16 else
  17     cnt <= cnt +1'b1;
  18
  19//out     
  20always@(posedge   sclk or negedge rst_n)
  21 if(rst_n ==1'b0)
  22     out <=1'b0;
  23 else   if(cnt ==4'd15)
  24     out <=~out;
  25
  26endmodule
  ```

  **我们比较器要将cnt的每一个比特都和4‘d15的每一位进行比较，也就是判断(cnt== 4’b1111)，会浪费更多的资源。而我们今天想到了“&”的用法就可以实现妙用，我们将判断条件改为(&cnt == 1‘b1)，当计数器计数到15时，即所有的比特都为变为了1，那么&cnt为1‘b1，而其余情况&cnt都为1’b0，这样比较的位数就只有1位了，节省了资源。**

- **常见比较器写法：**

  1. always(*) if else
  2. assign o = (sel)? a:b;
  3. always(*) case endcase

- **循环语句相关：**

  主要包含 for、while、forever、repeat 四类语句，但**只有 for 语句才有可能具备可综合性**，其余均为测试验证所准备。

  for 语句理解为：

  　　　　for(循环变量赋初值；循环结束条件；循环变量增值)执行语句

  for 循环的例子如下，这是最原始的一个8bit 乘法器实现，其中<<表示左移，等效于乘以2 的移位次方：

  ```verilog
  module mac_8 #(parameter size = 8)(
      input wire [size-1:0] opa, opb,
      output reg [2*size-1:0] mult_out
      );
  reg[2*size-1:0] result;
  integer bindex;
  always @(*)begin
      result =  opb[0]?opa:0;
      for( bindex=1; bindex<=size-1; bindex=bindex+1 )begin//根据乘法特性，判断后是否进行移位
          if(opb[bindex]) result = result + (opa<<(bindex));
       end
      mult_out = result;
  end
  endmodule
  ```

  **注意：不常用的原因是单纯复制电路，不能有效利用硬件资源。**

- **tb重的SV常见知识点：**

  - fork_join：

    块语句是指将两条或者两条以上的语句组合在一起，使其在格式上更像一条语句。块语句分为两种：

    1. 用begin_end语句，通常用来标识顺序执行的语句，用它标识的块称作**顺序块**；

       在begin-end语句块中，begin-end和fork-join块可以**相互嵌套，也可以自我嵌套**。如果begin-end中包含有**局部声明**，则他必须被命名（必须有一个标志）。如果要禁止一个begin-end块，那么被禁止的begin-end必须有名字。

    2. 用fork_join语句，通常用来标识并行执行的语句，用它标识的块称作**并行块**。

       当按**时间排序在最后**的语句执行完成后，或者一个disable语句执行时，程序流程控制跳出该模块。

    ![对比](https://img-blog.csdnimg.cn/20190825225329914.png)

- **信号类型integer：**

  integer类型也是一种寄存器数据类型，integer类型的变量为**有符号数**，而reg类型的变量则为无符号数，除非特别声明为有符号数，还有就是**integer的位宽为宿主机的字的位数**，但最小为32位。reg，integer，real，time都是寄存器数据类型，大多数的矢量类型（reg或者net）都被默认当做无符号数。integer和real是个例外，它们被默认为当做有符号数。通常，**real类型是不可综合的。**

- **inout端口：**

  inout是一个双向端口，实现为使用三态门，第三态为高阻态‘z’。在实际电路中高阻态意味着响应的管脚悬空、断开。当三态门的控制信号为真时，三态门选通，作输出端口使用；控制信号为假时，三态门是高阻态，作输入端口用。**inout端口不能声明为reg类型，只能是wire类型。**

  参考如下代码使用：

  ```verilog
  inout data_inout;
  input data_in;
  
  reg data_reg;//data_inout的映象寄存器
  reg link_data;
  
  assign data_inout=link_data?data_reg:1’bz;
  //link_data控制三态门 
  //对于data_reg,可以通过组合逻辑或者时序逻辑根据data_in对其赋值
  //通过控制link_data的高低电平,从而设置data_inout是输出数据还是处于高阻态
  //如果处于高阻态,则此时当作输入端口使用
  ```

- **task和function：**

  > **任务、函数的定义和调用都包括在一个module的内部，他们一般用于行为级建模，在编写Testbench时用的较多，而在写可综合的代码时要少用。**

  function的定义：
  function<返回值类型和位宽> <函数名>

  　<入口参量和类型声明>

  　<局部变量声明>

  　行为语句；

  endfunction

  定义function时，要注意以下几点：

  1. function定义结构不能出现在任意一个过程块(always块或者initial块)的内部；
  2. function定义**不能包括有任何时间控制语句**，即任何用#，@或wait来标识的语句；
  3. **定义function时至少要有一个输入参量**；
  4. 定义function时，在function内部隐式地将函数名声明成一个寄存器变量，在函数体中必须有一条赋值语句对该寄存器变量赋以函数的结果值，以便调用function时能够得到返回的函数值。如果没有指定的返回值的宽度，function将缺省返回1位二进制数。

  function的调用：

  　　<函数名>  (<输入表达式1>,...,<输入表达式n>) ;

  输入表达式与函数定义结构中的各个输入端口一一对应，这些输入表达式的排列顺序必须与各个输入端口在函数定义结构中的**排列顺序一致**。

  **function的调用既可以出现在过程块中又可以出现在assign连续赋值语句之中**；另外，function定义中声明的所有局部变量寄存器都是**静态的**，即function中的局部寄存器在function的多个调用之间保持他们的值。

  **任务(task)**类似于一般编程语言中的Process(过程)，它可以**从描述的不同位置执行共同的代码**。通常把需要共用的代码段定义为task,然后通过task调用来使用它。

  task的定义

  task<任务名>；

  　端口与类型说明；

  　变量声明；

  　语句1；
  　。。。

  　语句n；

  endtask

  在定义一个task时，必须注意以下几点：

  1. 任务定义结构不能出现在任何一个过程块内；
  2. **一个task可以没有输入/输出端口**，当然也可以有；
  3. **一个task可以没有返回值**，也可以通过输出端口或双向端口返回一个或多个值；
  4. 除任务参数外，task还能够引用说明任务的模块中定义的任何变量；

  task的调用：

  task调用语句给出传入任务的参数值和接收结果的变量值，

  <任务名>  (端口1，端口2，... ，端口n);

  在调用task时，必须注意一下几点：

  1. task调用是过程性语句，因此**只能出现在always过程块和initial过程块中**，调用task的输入与输出参数**必须是寄存器类型**的；
  2. task调用语句中的列表必须与任务定义时的输入、输出和双向端口参数说明的**顺序相匹配**。
  3. 在调用task时，参数要**按值传递**，而不能按地址传递(和其他语言的不同)；
  4. 在一个task中，可也直接访问上一级调用模块中的任何寄存器；
  5. 可以使用循环中断控制语句disable来中断任务执行，在task被中断后，程序流程将返回到调用task调用的地方继续向下执行。

  **task和function的不同点：**

  1. function只能与主模块共用一个仿真时间单位，而task可以定义自己的仿真时间单位；
  2. function不能调用任务，而task可以调用函数；
  3. function至少需要一个输入变量，而task可以没有或者有很多个任意类型的变量；
  4. function返回一个值，而task则不返回值。

- **可综合和不可综合：**

  - 所有综合工具都支持的结构：always，assign，begin，end，case，wire，tri，supply0，supply1，reg，integer，default，for，function，and，nand，or，nor，xor，xnor，buf，not，bufif0，bufif1，notif0，notif1，if，inout，input，instantitation，module，negedge，posedge，operators，output，parameter。运算符包括：> , < , >= , <= , == , != , >>, << (位移量为变量，则会综合出通用位移器), &, |, ^ , +, - ,*, /(某些综合工具可能不支持){[ ],[ ]} ：部分选取和位选取操作。

  - 所有综合工具都不支持的结构：time，defparam，$finish，fork，join，initial，delays，UDP，wait。运算符包括： === ， !== ,  {[ ],[ ]} （非常量部分选取）。

  - 有些工具支持有些工具不支持的结构：casex，casez，wand，triand，wor，trior，real，disable，forever，arrays，memories，repeat，task，while。

  - **不能综合的语句：**

    1. initial：不一定能综合，看编译器。
    2. events：event在同步test bench时更有用，不能综合。
    3. real：不支持real数据类型的综合。
    4. time：不支持time数据类型的综合。
    5. force 和release：不支持force和release的综合。
    6. assign 和deassign：不支持对reg 数据类型的assign或deassign进行综合，支持对wire数据类型的assign或deassign进行综合。
    7. fork join：不可综合，可以使用非块语句达到同样的效果。
    8. primitives：支持门级原语的综合，不支持非门级原语的综合。
    9. table：不支持UDP 和table的综合。
    10. 敏感列表里同时带有posedge和negedge：如：always @(posedge clk or negedge clk) begin...end。这个always块不可综合。
    11. 同一个reg变量被多个always块驱动。
    12. 延时：以#开头的延时不可综合成硬件电路延时，综合工具会忽略所有延时代码，但不会报错。
    13. 与X、Z的比较。

  -  **可综合模型的原则**

      要保证Verilog HDL赋值语句的可综合性，在建模时应注意以下要点：

    1. 不使用initial。
    2. 不使用#10。
    3. 不使用循环次数不确定的循环语句，如forever、while等。
    4. 不使用用户自定义原语（UDP元件）。
    5. 尽量使用同步方式设计电路。
    6. 除非是关键路径的设计，一般不采用调用门级元件来描述设计的方法，建议采用行为语句来完成设计。
    7. 用always过程块描述组合逻辑，应在敏感信号列表中列出所有的输入信号。
    8. 所有的内部寄存器都应该能够被复位，在使用FPGA实现设计时，应尽量使用器件的全局复位端作为系统总的复位。
    9. 对时序逻辑描述和建模，应尽量使用非阻塞赋值方式。对组合逻辑描述和建模，既可以用阻塞赋值，也可以用非阻塞赋值。但在同一个过程块中，最好不要同时用阻塞赋值和非阻塞赋值。
    10. 不能在一个以上的always过程块中对同一个变量赋值。而对同一个赋值对象不能既使用阻塞式赋值，又使用非阻塞式赋值。
    11. 如果不打算把变量推导成锁存器，那么必须在if语句或case语句的所有条件分支中都对变量明确地赋值。
    12. 避免混合使用上升沿和下降沿触发的触发器。
    13. 同一个变量的赋值不能受多个时钟控制，也不能受两种不同的时钟条件（或者不同的时钟沿）控制。
    14. 避免在case语句的分支项中使用x值或z值。

- **注意点：**

  - 当一个wire 类型的信号没有被驱动时，缺省值为Z（高阻）。

## 5. 竞争冒险以及如何消除？

如下图所示，在组合逻辑电路中我们将门电路两个输入信号同时向相反的逻辑电平跳变(一个从1变为0，另一个从0变为1)的现象称为竞争。由于竞争而在电路输出端可能产生尖峰脉冲的现象就称为竞争-冒险。通俗的理解就是组合逻辑电路中会在两个输入变化的地方产生干扰即毛刺，电路中的毛刺是我们不希望产生的，会使我们设计的电路产生不稳定因素，非常危险。

![img](https://mmbiz.qpic.cn/mmbiz_png/RUdmIJpZSdH1EvNCT63DT3A81ibCgNa25FCcO8DLPqXW8V4QINTPyL1pJlOiaJX45cR7PwHYCxkDP9AnZmMbrib6g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

接下来我们还要知道如何分析一个电路中是否存在竞争-冒险现象。在输入变量每次只有一个改变状态的简单情况下，可以通过逻辑函数式判断组合逻辑是否存在竞争-冒险现象。如果输出端电路的两个输入信号A和A’是输入变量A经过两个不同的传输途径而来的，那么的那个输入变量A的状态发生突变时输出端便有可能产生尖峰脉冲。

如何判断产生了竞争-冒险呢？主要方法有四种：

**1）代数法：**只要输出端的逻辑函数在一定条件下化简成Y = A+ A'（零型冒险） 或Y = A* A'（1型冒险） 且A和A'是由A经过不同的路径过来的，则可判定存在竞争-冒险现象。

**2）利用工具分析法：**通过在计算机上运行数字电路的模拟程序，能够迅速查出电路是否会存在竞争-冒险现象。目前已有这类成熟的程序可供选用。

**3）实验法：**用实验来检查电路的输出端是否有因为竞争-冒险现象而产生的尖峰脉冲。这时加到输入端的信号波形应该包含输入变量的所有可能发生的状态变化。

**4）卡诺图法：**如果组合逻辑函数所对应的卡诺图中存在相切的圈，而且相切的方格又没有同时被另一个圈包含，则当变量组合在相切的方格之间变化时，存在竞争-冒险现象。

<img src="https://mmbiz.qpic.cn/mmbiz_png/RUdmIJpZSdGWiayEGT9rIZLMxhibYDwTZ4law4T253pKnVY7OTSeUAEVcsxdMLG9VZYSNk8g8Sgklt3JP2ETnMmw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img" style="zoom:50%;" />

那么如何消除竞争-冒险现象呢？其主要的方法有如下三种：

**1）输出端接入滤波电容**

下面的电路中D = AB + A'C，当B = C = 1时，D = A + A' 所以输出会产生竞争-冒险现象。

<img src="https://mmbiz.qpic.cn/mmbiz_png/RUdmIJpZSdH1EvNCT63DT3A81ibCgNa25cGcicHc0se1XT8cWOJCuBgial1vP7ut4jib553dn96p0mX5p8ZlGaCZ3w/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img" style="zoom: 50%;" />

**2）引入选通脉冲或使用时序逻辑电路**

<img src="https://mmbiz.qpic.cn/mmbiz_png/RUdmIJpZSdH1EvNCT63DT3A81ibCgNa25wI70rP0pYEZyL8n7LATZuWoWTRJUpOGSvia9sicOcYm1fwEVhibdXyHZg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img" style="zoom: 50%;" />

**3）修改逻辑设计，增加冗余项**

我们从从布尔方程式的角度进行逻辑优化，将原逻辑表达式D = AB + A'C，添加冗余逻辑后变为D = AB + A'C + BC，这样当B = C = 1时就不会产生竞争-冒险现象。

由上面的分析知后级增加缓冲器并不会滤除竞争-冒险产生的毛刺，所以B项错误。由于逻辑门的延迟作用，竞争冒-险现象主要由两个输入信号同时向相反的逻辑电平跳变所生的，而不是由输入信号的尖峰干扰所导致的，所以屏蔽输入信号的尖峰干扰和前级加电阻并不可以消除经过组合逻辑后输出的毛刺，所以C项和D项也错误。 

## 6. setup和hold time

**建立时间**(Set Up Time，简写为Tsu或Ts)：是指在触发器的时钟信号上升沿到来以前，数据稳定不变的时间。

**建立时间的门限**(为了和建立时间区别开，所以简写为T_setup)：时钟沿来到之前数据必须保持稳定的最小时间，芯片选定即决定，和制作工艺有关。

**保持时间**(Hold Time，简写为Th)：是指在触发器的时钟信号上升沿到来以后，数据稳定不变的时间，如果保持时间不够，数据同样不能被稳定的打入触发器，Th就是指这个最小的保持时间。

**保持时间的门限**(为了和保持时间区别开，所以简写为T_hold)：时钟沿来到之后数据必须保持稳定的最小时间，芯片选定即决定，和制作工艺有关。

![image-20200818091350436](/Users/xmz/Library/Application Support/typora-user-images/image-20200818091350436.png)

如果我们想让系统中的时钟沿能够正确的采集到数据，那么需要建立时间的余量/裕量(Setup Slack，简写为Sslack) = 建立时间(Ts) - 建立时间的门限(T_setup) ≥ 0且保持时间的余量/裕量(Hold Slack，简写为Hslack) = 保持时间(Th) - 保持时间的门限(T_hold) ≥ 0，采集到的数据最准确的地方就是在满足建立保持时间的情况下时钟沿采集到数据的中间位置。

## 7. 同步和异步 组合和时序

> 好博文：https://blog.csdn.net/moon9999/article/details/101646671

**同步时钟sync是指时钟之间相位相对确定，异步时钟async是指时钟之间相位不确定。**例如33M和100M时钟就一定不可能是同步时钟，因为无论如何做不到相位保持一致；而50M和100M时钟就有可能是同步时钟，因为相位可以保持一致。

同步电路是由时序电路(寄存器和各种触发器)和组合逻辑电路构成的电路，其所有操作都是在严格的时钟控制下完成的。这些**时序电路共享同一个时钟CLK**，而所有的状态变化都是在时钟的上升沿(或下降沿)完成的。比如D触发器，当上升沿到来时，寄存器把D端的电平传到Q输出端。

异步电路主要是组合逻辑电路或包含多个时钟，用于产生地址译码器、FIFO或RAM的读写控制信号脉冲，但它同时也用在时序电路中，此时它没有统一的时钟，状态变化的时刻是不稳定的，通常**输入信号只在电路处于稳定状态时才发生变化**。对于组合逻辑电路，**一个时刻允许一个输入发生变化，以避免输入信号之间造成的竞争冒险。**电路的稳定需要有可靠的建立时间和维持时间。

由于异步电路具有：**无时钟偏移（Skew）问题、低电源消耗、平均效能而非最差效能、模块性、可组合和可复用性等优点**，因此近年来对异步电路研究增加快速，论文发表数以倍增，而Intel Pentium 4处理器设计，也开始采用异步电路设计。当然异步电路设计也有很多缺点：**由于增加了控制和用于DFT的电路，异步电路的面积开销可能高达同步设计的的两倍**。而且由于**缺乏专用于异步设计的商用EDA工具**，而现在芯片设计的复杂度又越来越高，EDA工具对芯片设计来说是不可替代的，因此这一点也是我们对异步电路的实用性诟病最多的地方。

在**同步电路设计中一般采用D触发器，异步电路设计中一般采用Latch**。所以这也是为什么我们常常会听到有人说在FPGA设计中要尽量避免产生Latch的原因。

很多人都以为在同步电路的设计中一定不可以有异步电路的存在，异步电路的设计中也不可以有同步电路的存在，其实这都是不对的。**同步电路设计一定是整个电路是全局同步的设计，局部异步的设计；同样异步电路设计也一定是整个电路是全局异步的设计，局部同步的设计。**

组合逻辑的特点是任意时刻的输出仅仅取决于该时刻的输入，与电路原本的状态无关，逻辑中不牵涉跳变沿信号的处理。

时序逻辑是Verilog HDL 设计中另一类重要应用，其特点为任意时刻的输出不仅取决于该时刻的输入，而且还和电路原来的状态有关。

## 8. FPGA结构相关

- FPGA内部结构：

  - 可编程输入输出单元(IOB)：是芯片与外界电路的接口部分，完成不同电气特性下对输入/ 输出信号的驱动与匹配要求。
- 可配置逻辑块(CLB)：FPGA 内的基本逻辑单元。在赛灵思公司公司的FPGA 器件中，CLB 由多个( 一般为4个或2 个) 相同的Slice 和附加逻辑构成。每个CLB 模块不仅可以用于实现组合逻辑、时序逻辑，还可以配置为分布式RAM 和分布式ROM。
  
  - 数字时钟管理模块(DCM)：提供数字时钟管理和相位环路锁定。相位环路锁定能够提供精确的时钟综合，且能够降低抖动，并实现过滤功能。
- 嵌入式块RAM(block RAM)：块RAM可被配置为单端口RAM、双端口RAM、内容地址存储器(CAM) 以及FIFO等常用存储结构。
  
  - 丰富的布线资源：根据工艺、长度、宽度和分布位置的不同而划分为４类不同的类别。第一类是全局布线资源。第二类是长线资源。第三类是短线资源。第四类是分布式的布线资源。
- 内嵌专用硬核：DSP，CPU之类的。
  
- 逻辑电平的参数定义及对应关系

  **输入高电平-Vih：**逻辑电平1的输入电压，保证逻辑门的输入为高电平时，所允许的最小输入高电平，当输入电平高于Vih时，则认为输入电平为高电平。

  **输入低电平-Vil：**逻辑电平0的输入电压，保证逻辑门的输入为低电平时所允许的最大输入低电平，当输入电平低于Vil时，则认为输入电平为低电平。

  **输出高电平-Voh：**逻辑电平1的输出电压，保证逻辑门的输出为高电平时的输出电平的最小值，逻辑门的输出为高电平时的电平值都必须大于此Voh。

  **输出低电平**-**Vol**：逻辑电平0的输出电压，保证逻辑门的输出为低电平时的输出电平的最大值，逻辑门的输出为低电平时的电平值都必须小于此Vol。

  **阀值电平-Vt：**数字电路芯片都存在一个阈值电平，就是电路刚刚勉强能翻转动作时的电平。它是一个界于Vil、Vih之间的电压值，对于CMOS电路的阈值电平，基本上是二分之一的电源电压值，但要保证稳定的输出，则必须要求输入高电平> Vih，输入低电平<Vil，而如果输入电平在阈值上下，也就是Vil～Vih这个区域，电路的输出会处于不稳定状态。

  **TTL电平临界值：**

  Vohmin = 2.4V   Volmax = 0.4V   

  Vihmin = 2.0V    Vilmax= 0.8V

  **CMOS电平临界值（设电源电压为+5V）：**

  Vohmin = 4.99V  Volmax = 0.01V  

  Vihmin = 3.5V    Vilmax = 1.5V

  **综上所述以上参数的关系为：Voh> Vih > Vt > Vil > Vol。**

- 关于CTS：https://blog.51cto.com/14075497/2344300

- 噪声容限(Noise Margin)是指在前一极输出为**最坏**的情况下，为保证后一极正常工作，所允许的最大噪声幅度。

  高电平噪声容限=最小输出高电平电压-最小输入高电平电压。

  低电平噪声容限=最大输入低电平电压-最大输出低电平电压。

## 9. 复位相关

- 同步复位还是异步复位：

  在Altera芯片中综合同步复位和异步复位电路，我们可以发现采用**同步复位**会多出来一个选择器的结构，为什么多了一个选择器？原因就是由**Altera的最小逻辑单元LE中的寄存器结构决定的**，在Chip Planner视图中我们发现LE中的寄存器有一个连接到寄存器的异步复位信号！ACLR的PAD，也就是说**Altera器件中的基本单元就是由异步复位且低有效结构的寄存器组成的**，如果不按照这个现有的资源来设计我们就需要额外使用其他的资源，从而造成浪费，所以这就是我们所**“默认”Altera器件中往往都是异步复位低有效**的原因。

  Xilinx的芯片时规则又变了，官方文档《Vivado使用误区与进阶》中明确说明尽量**避免使用异步复位**，且如果使用复位就用**高复位**，巧的是刚好和Altera推荐的规则相反，也是因为内部结构决定的，这也是这两家公司非常有意思的地方，所以我们在开发Altera和Xilinx的芯片时复位要区别对待。

  同步复位相比异步复位多了一个mux，连接在D端。

- 异步复位同步释放：

  同步复位的D触发器和异步复位的D触发器的不同点是复位有效的条件是“立刻”执行还是等待“沿”再执行的区别。异步复位有一个明显的问题就是会产生亚稳态的问题。全局复位我们往往都是外接一个按键，异步复位时按键一旦按下就立刻进行复位，复位可以在任何时候发生，表面上看跟时钟没有关系，但真实情况是异步复位也需考虑时钟跳变沿，因为时钟沿变化和异步复位都可以引起Q端数据变化。如果异步复位信号跟时钟在一定时间间隔内发生变化（Removal time**恢复时间检查**和Recovery time**移除时间检查**，类似于建立/保持时间），就是说只要复位信号不在时钟有效沿附近变化（复位信号远离时钟有效沿），就可以保证电路的正常复位和撤销，否则Q值将无法确定即产生亚稳态现象。这个时候即使异步复位信号持续时间再长都没有办法，因为不定态已经传递下去。而同步复位就没有这种问题，所以我们需要结合一下两者的优点，**异步复位同步释放机制**。

- 复位带来的问题：

  只要存在复位都会增加布局布线的负担，因为复位会像时钟一样连接到每一个寄存器上，是相当复杂的工程，会**增加时序收敛的难度**。难道不用复位吗？也不完全是，我们还需要参考官方的建议，在《Vivado使用误区与进阶》中提到我们要遵循 Xilinx 建议的复位准则：（1）**尽量少使用复位**；（2）**必须复位时采用同步复位**；（3）**确保使用高电平有效的复位**；（4）**避免异步复位**（RAMB 和 DSP48 模块中不支持异步复位）。**如果不用复位那寄存器的初值我们怎么给呢？在代码中定义寄存器的时候直接在变量名后赋初值即可，Verilog-2001标准支持这种写法。**

## 10. 毛刺消除

大多数同学的第一反应是通过检测data_in信号高低电平的个数来滤除毛刺，这就把大家引入到了一条完全不同的解题思路中，如果一开始就想到通过检测data_in信号“沿”的方法也许就不会遇到计数器的坑了。如下图所示，蓝色竖虚线为下降沿，绿色竖虚线为上升沿。

![d4wZT0.png](https://s1.ax1x.com/2020/08/27/d4wZT0.png)

找到了“沿”后，就可以通过沿来判断毛刺了，为什么可以这样做？原因是**有电平的变化一定会产生沿的变化**，这种转化的思想一定不要忘记，我们可以通过计数器计数上升沿和下降沿的个数来判断毛刺。计数器检测到上升沿或下降沿标志信号就说明此时可能有抖动产生，计数器清零准备好计数，**如果计数器计数到3时还没有检测到新的沿**说明之前检测到的沿变化不是抖动，是正常的信号变化，我们就可以让输出信号data_out等于输入信号data_in的值了。这种方法也可以完美的将高电平或低电平宽度小于4个时钟周期的毛刺滤除掉，且思路和代码的编写都更加简单。

![img](https://mmbiz.qpic.cn/mmbiz_png/RUdmIJpZSdFmxLJNBqciazSOg4vMG5ibaDlZgDbxSO5t2tk3VdWLSBy6js0pQiavPB3rQuJbMd61pcgiahxYXtr8sQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

## 11. 静态时序分析

- **静态时序分析和动态时序分析的优缺点：**

  动态时序分析就是通常我们所说的仿真，**该仿真可以验证功能，也可以验证时序**，首先**确定测试向量**，输入硬件模型，进行仿真。由于为了完整地测试每条路径的功能或者时序是否都满足，**测试向量需要很大**，也不能保证100%的覆盖率。如果到了门级的仿真将非常消耗时间。

  静态时序分析**只能分析时序要求而不能进行功能验证**。**不需要测试向量**，能比动态时序分析快地多的完成分析。静态时序分析**只能对同步电路**进行分析，而**不能对异步电路**进行时序分析。但是它却可以验证每一条路径，发现时序的重大问题，比如建立时间和保持时间冲突，slow path以及过大的时钟偏移。

  静态时序分析可以大大提高仿真时间，并能100%覆盖所有的路径。它通过预先计算所有的延时来提高速度。包**括内部门延时以及外部的线延时**。静态时序分析并不是简单的把各个延时相加，而是引入真值表，分析各种输入情况下**所有可能经过的路径**，而且能**识别flase path**。但是由于在深亚微米的工艺条件下，静态时序分析不能完整的把所有影响延时的因素给包含进去，因此在关键路径方面，便可以用STA工具导出关键路径的spice网表，用门级或者管级仿真工具进行电路仿真，以确定时序的正确性。

- 静态时序分析计算

  **建立时间的公式为：**Ts = T_cycle – T1 + △T = T_cycle –（Tco + Tdata）+ △T

  **保持时间的公式为：**Thold= （Tco + Tdata）– △T

  结合上面介绍的建立时间门限和保持时间门限来比较判断，要求Sslack和Hslack的值都要大于零。
  
- **PVT对电路性能的影响**

  制造工艺（Process）、工作电压（Voltage）、温度（Temperature）对芯片运行的速度影响很大，这三个量也就是我们常说到的PVT，数字电路设计时会做静态时序分析（STA），分析在各种PVT条件下芯片的时序是否满足要求，也就是对芯片的工作速度进行分析。在分析建立时间是否满足时序要求时要使用慢速模型，即**高温+低压+慢速模型**；分析保持时间是否满足时序要求时要使用快速模型，即**低温+高压+快速模型**。而封装方式不是对电路工作速度的主要影响因素。
  
- 关于clock jitter和clock skew：

  - **Clock Jitter（时钟抖动）**：是指芯片在某个给定的时间点上时钟周期发生暂时性变化，从而导致时钟在不同的周期上加长或者变短。换句话来说就是指，两个时钟周期之间存在差值，这个误差是在时钟内部产生的，**与晶振或者内部的PLL有关。与时钟的布局布线无关。**
  - **Clock Skew（时钟偏移）：**是由于**布线长度及负载不同引起的**，导致同一个时钟信号到达相邻两个时序单元的时间不一致。话句话说就是，时钟偏斜指的是同一个时钟信号到达两个不同寄存器之间的时间差值，**时钟偏斜永远存在，到一定程度就会严重影响电路的时序。**
  - **skew通常是时钟相位上的不确定，而jitter是指时钟频率上的不确定（uncertainty)。**造成skew和jitter的原因很多。由于时钟源到达不同寄存器所经历路径的驱动和负载的不同，时钟边沿的位置有所差异，因此就带来了skew。而由于晶振本身稳定性，电源以及温度变化等原因造成了时钟频率的变化，就是jitter。
  - 在不考虑skew和jitter的情况下，及t(clk1)和t(clk2)同频同相时，时钟周期T和t(hold)需要满足：（1）T > t(c-q) + t(logic) + t(su)：（2）t(hold) < t(c-q, cd) + t(logic, cd)这样才能保证电路的功能正常，且避免竞争的发生。**如果考虑CLK2比CLK1晚t1的相位，及skew=t1。则 t(hold) < t(c-q, cd) + t(logic, cd) - t1，这意味着电路由更大的倾向发生hold time violation；如果考虑CLK1比CLK2晚t2的相位，及skew=-t2，则 T > t(c-q) + t(logic) + t(su) + t2这意味着电路的性能下降了，但由于R2的hold time始终满足，所以不会有竞争的麻烦存在。**
  - clock uncertainty = clock jitter + clock skew.

- FPGA设计的几种常用基本时序路径：

  - clock-to-setup路径：

    clock-to-setup路径**从触发器的时钟输入端开始，结束于下一级触发器，锁存器或者RAM的输入端**，对终止端的数据信号要求一定的建立时间。如下图所示：

    ![wEqmAP.png](https://s1.ax1x.com/2020/09/05/wEqmAP.png)

    该条路径包括了触发器内部clock-to-Q的延迟，触发器之间的由组合逻辑造成的路径延迟以及目标触发器的建立时间，其延时是数据从源触发器开始，在下一个时钟沿来到之前通过组合逻辑和布线的最大时间，Clock-to-Setup时间可通过约束文件中的周期约束来限制。

  - Clock-to-Pad路径：

    Clock-to-Pad路径**从寄存器或者锁存器的时钟输入端开始，终止于芯片的输出引脚**，中间经过了触发器输出端以及所有的组合逻辑，如下图所示。

    ![wEOkdI.png](https://s1.ax1x.com/2020/09/05/wEOkdI.png)

    这条路径包括了经过触发器的延时和从触发器到输出引脚之间的逻辑延迟，在约束文件中，可以通过OFFSET语句和FROM：TO来约束，如果使用OFFSET语句，那么时延计算时会包含时钟输入BUFFER/ROUTING延时；如果使用FROM:TO约束，则延时从触发器自身开始，不包括输入路径，比较精确，所以使用相对更频繁一些。

  - Pad-to-Pad路径：

    Pad-to-Pad路径**从芯片输入信号端口开始，结束于芯片输出信号端口，中间包含所有组合逻辑，但并不包含任何同步逻辑**如图所示：

    ![wEXuh6.png](https://s1.ax1x.com/2020/09/05/wEXuh6.png)

    Pad-to-Pad路径延时是数据输入到芯片，经过逻辑延时和布线时延后再输出芯片的最大时间要求，在约束文件中任然通过FROM：TO来约束，其语法如下：TIMESPEC TS_aa = FROM PADS TO PADS 10 ;

  - pad-to-setup路径：

    Pad-to-setup路径从**芯片的输入信号端口开始，结束于同步电路模块（触发器，锁存器和RAM）**，对相应的数据信号要求一定的建立时间，如下图所示：

    ![wVifoD.png](https://s1.ax1x.com/2020/09/05/wVifoD.png)

    该路径可以通过BUFFER和所有组合逻辑，不包含任何同步电路模块和双向端口，是数据到达芯片的最大时间要求，和Clock-to-Pad一样，该路径可以通过OFFSET和FROM:TO来设计，其中OFFSET语句的属性设置为OFFSET IN BEFORE。例如：OFFSET = IN 10 ns BEFORE my_clk TIMEGRP My_FFS;

  有关详情参照：https://www.cnblogs.com/IClearner/p/6624722.html

## 12. FPGA的仿真

在FPGA设计流程中，所有的代码其最后都会生成一个个的网表文件，这些网表文件就是FPGA最底层的东西，它反映着整个工程的门电路搭建。

我们用Verilog代码设计数字电路然后进行综合，Verilog语言只是代码，它仅仅描述了数字电路的功能，也就是只对电路模块进行行为级的描述。而计算机对Verilog不能直接识别，所以要通过编译器和综合工具进行翻译。编译器检查你的语法错误，以及初步逻辑功能是否正确，然后综合工具再将Verilog语言所描述的电路功能转化成“网表”。综合以后就会生成网表文件，这个文件只是一个电路的雏形，这步完成以后你可以看到RTL电路（RTL级即寄存器级，可以看到寄存器和门电路，主要体现的是逻辑连接关系和模块间的结构关系，和具体的FPGA器件无关）。也可以看到Technology 电路（将RTL电路所表达的结构进行优化，增加或减少一些模块，更接近于最后底层硬件映射的结果，以便于映射到具体的FPGA器件上），就是综合器最后综合出了你设计的功能的逻辑电路，放在网表文件中。到网表层时，你的HDL语言已经完成了自身的使命（语言已经转化成电路了），这时还需要用综合器生成的网表文件根据不同的FPGA来具体的细化这张网表。比如说FPGA开发工具可以具体的算出某个信号的延迟是多少，其中包括多少的走线延迟和多少的组合逻辑延迟。然后最后根据FPGA的内部结构决定把这个门放到哪里，这个就是布局和布线。

下面我们来说一下FPGA中的几种仿真。

**RTL仿真**（也叫行为仿真、功能仿真、可综合代码的仿真）：这个阶段的仿真可以用来检查代码中的语法错误以及代码行为的正确性，**其中不包括延时信息**。如果没有实例化一些与器件相关的特殊底层元件的话，这个阶段的仿真也可以做到与器件无关。仿真时间需要编写的Verilog待测试源文件以及Testbench仿真文件。如果用到了PLL等IP核，还需要挂载器件库文件。

**网表仿真：**通过网表反标标准延时格式文件（SDF）进行仿真，**仿真速度较RTL仿真慢**，由于标准延时格式文件通过SDC约束和单元逻辑延时和线网延时而来，**可以发现约束问题**。

如果设计的规模较大的话，网表仿真所耗费的时间就比较长，所以常采用形式验证手段来保证门级网表在功能上与RTL设计保持一致，配合静态时序分析工具保证门级网表的时序。网表仿真中的门级仿真可以发现异步问题

## 13. 低功耗设计

芯片功耗分为动态功耗和静态功耗两大部分。

- **动态功耗：**动态功耗是电路在工作时（翻转时）所消耗的能量。对于CMOS电路来说，它又分为开关功耗和短路功耗。开关功耗为电路翻转时对负载电容充电的功耗，短路功耗为输入翻转时，PMOS和NMOS同时打开的瞬间电流形成的功耗。

  可表示为：$P_{dyn}$ = $(C_{L} * V_{dd}^2 * P_{tran} * F) + (t_{tran} * V_{dd} * I_{peak} * F)$如果是反转率的话要除以2。

  其中，CL为电路总负载电容；Vdd为工作电压；Ptran为工作电路所占比例；F为工作时钟频率；ttran为PMOS，NMOS同时导通时间；Ipeak为短路电流。

- **静态功耗：**静态功耗是电路在没有翻转时，晶体管中漏电流造成的功耗。静态功耗主要有两种漏电流，一种是亚阈值电流，一种是pn结反向漏电电流。**高温会使亚阈值电流大幅度提高**，几乎是指数级别的，**从而导致功耗的增加。**

晶体管微缩到一定程度以后量子隧穿效应（指像电子等微观粒子能够穿入或穿越位势垒的量子行为）开始慢慢介入，使得晶体管漏电现象开始严重，动态功耗不再是总功耗预算中的主要因素，而**漏电功耗则占了预算的绝大部分**。漏电现象的出现打破了原先登纳德所提出的定律（晶体管面积的缩小使得其所消耗的电压以及电流会以差不多相同的比例缩小。也就是说，如果晶体管的大小减半，该晶体管的静态功耗将会降至四分之一）。功耗增大除了更费电不环保之外，带来的最大问题是增加的功耗会转化为热量。在微小的芯片面积上大量功耗密集堆积会导致温度急剧增加。如果散热做的不好，芯片的寿命将大大减少甚至变得不稳定。

常见低功耗设计：

1. **DVFS动态电压频率调整技术：**目的是根据的芯片当时的实际功耗需要设定工作电压和时钟频率，这样可以保证提供的功率既满足要求又不会性能过剩，从而可以降低功耗。DVFS技术利用了CMOS芯片的特性，CMOS芯片的能量消耗正比于电压的平方和时钟频率。DVFS技术是以延长任务执行时间为代价来达到减少系统能量消耗的目的，体现了功耗与性能之间的权衡。然而不管是电压调节还是频率调节，都会造成系统性能的损失，并增加系统的响应延迟。
2. **电源门控：**是一种在65nm和45nm工艺节点将发挥更重要作用的技术。电源门控（有人也称为电源关断）需要插入开关来关断非活动功能块的电源。不过电源门控有好的一面，也有不太好的一面。它能显著地减少漏电功能一到三个数量级。但是电源门控会给设计流程带来很大的复杂性。除了必须指出在那里放置电源开关外，你必须指出将它们做成多大或多小。**减小静态功耗**
3. **门控时钟：**众所周知，在数字IC设计中，时钟信号的翻转率是比较高的，因此它的功耗约占整个芯片功耗的20-30%。传统的设计方法是时钟信号一直是存活着的（常开），门控时钟技术就是根据设计，将暂时不用的模块的时钟信号通过一个控制信号gating住，降低这个模块的时钟信号翻转率，从而降低芯片功耗的一种技术。**减小动态功耗。**
   - 时钟与使能相与给后端时钟：这种系统时钟门控的机制算然简单，但是容易使门控后的时钟不完整（时钟一半的时候就使能了，导致输出端时钟不完整），甚至产生毛刺。
   - <img src="/Users/xmz/Library/Application Support/typora-user-images/image-20200831113106537.png" alt="image-20200831113106537" style="zoom:50%;" />

## 14. 数字前端和后端流程

**数字前端以设计架构为起点，以生成可以布局布线的网表为终点；是用设计的电路实现想法；**

主要包括：基本的RTL编程和仿真，前端设计还可以包括IC系统设计、验证(verification)、综合、STA、逻辑等值验证 (equivalence check)。其中IC系统设计最难掌握，它需要多年的IC设计经验和熟悉那个应用领域，就像软件行业的系统架构设计一样，而RTL编程和软件编程相当。

**数字后端以布局布线为起点，以生成可以可以送交foundry进行流片的GDS2文件为终点；是将设计的电路在工艺上实现想法。**

主要包括：后端设计简单说是P&R，但是包括的东西不少，像芯片封装和管脚设计，floorplan，电源布线和功率验证，线间干扰的预防和修正，时序收敛，STA，DRC，LVS等，要求掌握和熟悉多种EDA工具以及IC生产厂家的具体要求。

**数字前端设计的一般流程：**

1. 规格制定

   芯片规格，也就像功能列表一样，是客户向芯片设计公司（称为Fabless，无晶圆设计公司）提出的设计要求，包括芯片需要达到的具体功能和性能方面的要求。

2. 详细设计

   Fabless根据客户提出的规格要求，拿出设计解决方案和具体实现架构，划分模块功能。目前架构的验证一般基于SystemC语言，对构架模型的仿真可以使用SystemC的仿真工具。其中典型的例子是Synopsys公司的CoCentric和Summit公司的Visual Elite等。

3. HDL编码

   使用硬件描述语言（VHDL，Verilog HDL，业界公司一般都是使用后者）将模块功能以代码来描述实现，也就是将实际的硬件电路功能通过HDL语言描述出来，形成RTL（寄存器传输级）代码。

   设计输入工具：具有强大的文本编辑功能，多种输入方法（VHDL，Verilog，状态转移图，模块图等），语法模板，语法检查，自动生产代码和文档等功能。如Active-HDL,VisualVHDL/Verilog等。

   RTL分析检查工具：Synopsys LEDA

4. 仿真验证

   仿真验证就是检验编码设计的正确性，检验的标准就是第一步制定的规格。看设计是否精确地满足了规格中的所有要求。规格是设计正确与否的黄金标准，一切违反，不符合规格要求的，就需要重新修改设计和编码。

   设计和仿真验证是反复迭代的过程，直到验证结果显示完全符合规格标准。

   仿真验证工具Synopsys的VCS，Mentor ModelSim，Cadence Verilog－XL，Cadence NC-Verilog。

5. 逻辑综合――Design Compiler

   仿真验证通过，进行逻辑综合。逻辑综合的结果就是把设计实现的HDL代码翻译成门级网表netlist。综合需要设定约束条件，就是你希望综合出来的电路在面积，时序等目标参数上达到的标准。逻辑综合需要基于特定的综合库，不同的库中，门电路基本标准单元（standard  cell）的面积，时序参数是不一样的。所以，选用的综合库不一样，综合出来的电路在时序，面积上是有差异的。

   一般来说，综合完成后需要再次做仿真验证（这个也称为后仿真，之前的称为前仿真）

   逻辑综合工具Synopsys的Design Compiler（DC），Cadence的 PKS，Synplicity的Synplify等。另外，和综合工具配合使用的还有很多其他工具，如静态时间分析工具，等效性检查工具等等。Synopsys公司和Cadence公司都提供完整的工具包。

   5.1.  STA

   Static Timing Analysis（STA），静态时序分析，这也属于验证范畴，它主要是在时序上对电路进行验证，检查电路是否存在建立时间（setup  time）和保持时间（hold time）的违例（violation）。这个是数字电路基础知识，一个寄存器出现这两个时序违例时，是没有办法正确采样数据和输出数据的，所以以寄存器为基础的数字芯片功能肯定会出现问题。STA工具有Synopsys的Prime Time。

   5.2.  形式验证

   这也是验证范畴，它是从功能上（STA是时序上）对综合后的网表进行验证。常用的就是等价性检查（Equivalence Check）方法，以功能验证后的HDL设计为参考，对比综合后的网表功能，他们是否在功能上存在等价性。这样做是为了保证在逻辑综合过程中没有改变原先HDL描述的电路功能。形式验证工具有Synopsys的Formality。前端设计的流程暂时写到这里。**从设计程度上来讲，前端设计的结果就是得到了芯片的门级网表电路。**

**总结图：**

![img](https://img-blog.csdnimg.cn/20200811152555148.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnNpc3Rsenk=,size_16,color_FFFFFF,t_70)

## 15. 时序优化的方法

时序优化的目的：**满足系统正常运行时所需要的建立、保持时间**，即：Sslack（建立时间的余量）= [T_cycle –（Tco + Tdata）+ △T] – T_setup ≥ 0。Hslack（保持时间的余量）= [（Tco + Tdata）–△T] – T_hold ≥ 0

**根据时序分析理论公式优化**

根据公式可以看出同一系统内的建立时间余量和保持时间余量是一对**矛盾体**，如果建立时间余量大了，保持时间余量必定会缩小，反之亦然。我们需要做的就是让建立保持时间余量和保持时间余量尽量保持平衡。如果建立时间余量较小或者不满足要求，我们就可以根据公式来分析满足建立时间的要求。T_cycle一般系统时钟在设计之初都是确定的，后期不能修改。Tco作为寄存器的固有属性往往都是固定好的，不能改变。我们可以在建立时间余量公式中减小Tdata，怎么减小Tdata呢？我们知道Tdata是寄存器之间路径所造成的延时，其中又包括布线延时和组合逻辑延时，所以我们要**尽量减小布线延时和组合逻辑延时**，如何降低布线延时和组合逻辑延时呢？

1. **减小扇出Fanout**，扇出指模块直接调用的下级模块的个数，如果这个数值过大的话，在FPGA直接表现为**Net Delay较大**，不利于时序收敛。减小扇出的方法有：①**寄存器复制**，寄存器复制是解决高扇出问题最常用的方法之一，通过复制几个相同的寄存器来分担由原先一个寄存器驱动所有模块的任务，继而达到减小扇出的目的。②**Max_Fanout属性**，在代码中可以设置信号属性，将对应信号的Max_Fanout属性设置成一个合理的值，当实际的设计中该信号的Fanout超过了这个值，综合器就会自动对该信号采用优化手段，常用的手段其实就是寄存器复制。但最好不要在综合设置中指定，过低的扇出限制会造成设计堵塞反而不利于时序收敛，最好的方法是根据设计中时序最差路径的扇出进行针对性的优化。③**BUFG**，通常BUFG是用于全局时钟的资源，可以解决信号因为高扇出产生的问题。但是其一般用于时钟或者复位之类扇出超级大的信号，此类信号涉及的逻辑遍布整个芯片，而BUFG可以从全局的角度优化布线。如果不是关键时序路径，而且高扇出网络直接连接到触发器，对扇出超过25K的Net插入BUFG。

2. **减小逻辑级数Logic Level**，一个Logic Level的延迟对应的是一个LUT和一个Net的延迟，对于不同的器件，不同频率的设计能容纳的Logic Level是不同的，否则会造成时序收敛困难。Logic Levell太大的处理方法就是重定时（Retiming），**典型的重定时方法就是流水线，将过于冗长的组合逻辑增加寄存器进行打拍。**

一般hold time出了问题，**在组合逻辑中加入buffer**，增加延时。

对于时钟偏斜△T来说因为**不确定正负**，其对建立时间和保持时间的影响是相反的，所以我们希望|△T|**尽可能的小**，所以尽量不要用生成时钟，而**采用全局时钟**，这样才会有更小的|△T|。

在实践中，保持时间的问题往往是异步问题产生的。对于一个信号的跨时钟域问题，一般使用双寄存器法（对于慢采快的结绳法这里不讨论）。为了降低MTBF（Mean Time Between Failures，平均无障碍时间），这两个寄存器最好位于同一个Slice中（vivado中可以对寄存器属性标记）。

**通过代码风格优化**

关于Xilinx器件和Vivado适用的代码风格，《Vivado使用误区与进阶》有以下建议：

- 多使用Vivado自带的代码模板；
- **尽量避免使用异步复位；**
- **在模块边界上使用寄存器而非组合逻辑；**
- 使用流水结构来降低逻辑层数；
- 采用适当的RAM和DSP的实现方式（是否选用硬核）；
- 在综合后或是逻辑优化（opt_design）后的时序报告上分析代码优化的方向。
- 时钟管理单元尽量放在顶层，有助于以共享逻辑从而提高性能降低功耗。
- **如果并不需要优先级，尽量将If语句转化为case语句。**
- 尽量不要使用Don't Touch这类语句。如今Vivado综合工具已经很完善了，除非代码有问题或者手动复制寄存器，否则一般不会发生电路被综合掉的现象。使用这些语句会覆盖Vivado综合设置，导致电路没有得到充分的优化，给时序收敛造成困难。

**使用EDA开发工具的综合策略优化**

1. Vivado综合实现本质是时序驱动的，因此再也没有ISE那种用随机种子综合实现满足时序收敛的工具。通过Vivado在布局布线方面提供了几种不同的策略（directive）组合可以产生上千种不同的布局布线结果.

2. 使用Tcl脚本自定义布局布线过程，足以满足需求。Vivado可支持同时运行多个Implementation，为这种“设计时间换取性能”的方法提供了工具上的便利。

3. Implementation里Post-place Phys Opt Design和Post-route Phys Opt Design是没有使能的，工程后期使能这两个配置也能在一定程度上改善时序收敛。

## 16. 总线

- **AHB**（AdvancedHigh Performance Bus）是AMBA（AdvancedMicrocontroller Bus Architecture）V2.0总线规范的一部分，AMBA总线规范是ARM公司提出的总线规范，被大多数SoC设计采用，它规定了**AHB** （Advanced High-performance Bus)、**ASB** (Advanced System Bus）、**APB**（Advanced Peripheral Bus）。**AHB用于高性能、高时钟频率的系统结构**，典型的应用如ARM核与系统内部的高速RAM、NAND FLASH、DMA、Bridge的连接。**APB用于连接外部设备**，对性能要求不高，而考虑低功耗问题。**ASB是AHB的一种替代方案**。**AHB总线由AHB总线主机(Master)、AHB总线从机(Slave)和Infrastructure构成**。Infrastructure由仲裁器、数据多路选择器、地址控制多路选择器、译码器构成。AHB总线有以下特性：
  - Burst 传输 
  - Split 事务处理
  - 单周期Master移交
  - 单一时钟沿操作
  - 无三态。
  - 更宽的数据总线配置（64bit/128bit）

## 17. 奇偶数小数分频

**任意奇偶分频器：**

```verilog
01module  random_divider
02#(
03     parameter   DIVIDER_NUMBER = 3'd5//DIVIDER_NUMBER取值需大于1，当所需要分频数值大于设定位宽时要注意所有位宽的扩展
04)
05(  
06     input  wire   sclk   ,   //系统时钟50MHz
07     input  wire   rst_n  ,   //全局复位
08                                    
09     output wire   clk_out     //对系统时钟DIVIDER_NUMBER分频后的信号
10);
11
12reg    [3:0]  cnt;
13reg            clk1;
14reg            clk2;
15wire           clk_odd;
16wire           clk_even;
17
18//cnt:上升沿开始从0到(DIVIDER_NUMBER-1)循环计数
19always@(posedge sclk or negedge rst_n)
20     if(rst_n ==1'b0)
21         cnt <=3'b0;
22     else   if(cnt ==(DIVIDER_NUMBER-1))
23         cnt <=3'b0;
24     else
25         cnt <= cnt +1'b1;
26        
27//clk1:上升沿触发，占空比高电平维持(DIVIDER_NUMBER-1)/2个系统时钟周期，低电平维持(DIVIDER_NUMBER+1)/2个系统时钟周期
28always@(posedge sclk or negedge rst_n)
29     if(rst_n ==1'b0)
30         clk1 <=1'b1;
31     else   if(cnt ==(DIVIDER_NUMBER-1)/2)
32         clk1 <=1'b0;
33     else   if(cnt ==(DIVIDER_NUMBER-1))
34         clk1 <=1'b1;
35        
36//clk2:下降沿触发，占空比高电平维持(DIVIDER_NUMBER-1)/2个系统时钟周期，低电平维持(DIVIDER_NUMBER+1)/2个系统时钟周期
37always@(negedge sclk or negedge rst_n)
38     if(rst_n ==1'b0)
39         clk2 <=1'b1;
40     else   if(cnt ==(DIVIDER_NUMBER-1)/2)
41         clk2 <=    1'b0;
42     else   if(cnt ==(DIVIDER_NUMBER-1))
43         clk2 <=1'b1;
44
45//clk_odd:奇数分频时钟 
46assign clk_odd = clk1 & clk2;
47
48//clk_even:偶数分频时钟
49assign clk_even = clk1;
50
51//clk_out:判断分频是奇数还是偶数，然后对应输出
52assign clk_out =(DIVIDER_NUMBER/2==3'd0)? clk_even : clk_odd;
53
54endmodule 
```

**小数分频：**

在实际应用中，还经常会遇到小数分频。实现小数分频经常采用三种方法。

1. 用数字锁相环实现，先利用锁相环电路将输入时钟倍频，然后再利用分频器对新产生的高频信号进行分频得到需要的时钟频率。例如要实现5.7分频，可以先将输入的时钟10倍频，然后再将倍频后的时钟57分频，这样即可以精确实现5.7的小数分频。这样的好处可以做到精确分频。但是需要器件包含锁相环电路，但有的FPGA器件内部是不包含锁相环电路的，因此这种方法一般只在某些对信号频率精度要求较高的场合下或者所使用的器件支持的情况下使用。

2. 方法二是先设计两个不同分频比的整数分频器，然后通过控制两种分频比出现的不同次数来获取所需要的小数分频值，从而实现平均意义上的小数分频。N=M/P 式中，N表示分频比；M表示分频器输入脉冲数；P表示分频器输出脉冲数。当N为小数分频比时，又可以表示为N=K+10^(-n)X。式中K、n和X都为正整数，n表示小数的位数。由以上两式可得M=(K+10^(-n)X)P,令P=10^(n),有M=10^n*K+X,即在进行(10^n)次K分频时多输入X个脉冲。下面实现一个分频系数为8.1的小数分频器。通过计数器先做9次8分频，再做一次9分频，这样总的分频值为：N=（89+91）/(9+1)=8.1*

   示例如下：
   分频系数为10.1 ，可以将分频器设计为9次10分频，1次11分频，这样总的分频值
   为（9*10+1*11）/（9+1）=10.1
   要从整体上去理解，应该就是先对CLK来9次10分频，这样就经过了90个CLK
   周期，得到9个分频后的DIVCLK脉冲，再对CLK来一个11分频，得到1个分频后的DIVCLK
   脉冲。这样虽然局部看来是10分频和11分频，但是总的看来，经过90＋11＝101个CLK脉冲后，共得到9＋1＝10个分频后的DIVCLK脉冲，岂不就是101／10＝10.1分频了。

3. N+0.5分频：

   如N=3时进行3.5分频。

   先将clk时钟周期的一半记作clk_half，即一个高电平或一个低电平时间。

   对2*(N+0.5) = 2N+1，这个数一定是奇数，按照奇数分频的思路做，也取clk_p和clk_n，但是计数值不一样，一个计数N个clk时钟周期（2N个clk_half周期），一个计数2N+2个clk_half，且两者的位置关系如图所示，这样，两者做“与”运算，则所得信号一个周期的高低电平共有2N+1个clk_half周期，即(N+0.5)个clk周期。

   ![img](https://pic2.zhimg.com/80/v2-45bbb3bfd8ea5f164af8c2ed1b8cd5dd_720w.jpg)

## 18. 亚稳态以及如何预防

每当**违背建立和保持时间（或是Removal time和Recovery time）时**，亚稳态就会出现。在以下的情况下，可能违背时序要求：

- 输入信号是异步信号
- 时钟偏移超过容限值
- 信号在两个不同频率或者同频不同相的时钟域下工作
- 组合延时过大或过小使触发器的输入信号在亚稳态窗口内发生变化

亚稳态会引起过多的传输延时和系统故障。虽然**亚稳态不能根除**，但是可以减小亚稳态发生的概率。避免亚稳态发生常见方法就是使用同步器。

**在两个异步系统交界的地方亚稳态是不可避免的。**但以下建议可以明显减小亚稳态发生的概率：

1. 引入同步机制

   最常见的方法就是在跨时钟域内的信号后加上同步触发器。该方法是用一个时间周期(不包括第二级触发器的建立时间)来解决第一级同步触发器亚稳态的问题。（详情查看跨时钟域处理）

   ![N级同步器](https://images2015.cnblogs.com/blog/745855/201509/745855-20150907144208215-1909824415.jpg)

2. 选择采样相应更快的触发器(亚稳态窗口小)

3. 降低采样速率（减小时钟）

4. 避免使用d*V*d*t* 低的输入信号

## 19. FIFO相关

- 同步FIFO：读时钟和写时钟为同一个时钟。

- 异步FIFO：读写时钟不一致，读写时钟是互相独立的。

- 同步FIFO实现代码：

  ```verilog
  //同步FIFO
  module fifo(clk, rst, read, write, fifo_in, fifo_out, 
  			fifo_empty, fifo_half, fifo_full);
  	input clk, rst, read, write;
  	input [15:0]fifo_in;
  	output [15:0]fifo_out;
  	output fifo_empty, fifo_half, fifo_full;
  	
  	reg [15:0]fifo_out;
  	reg [15:0]ram[15:0];
  	reg [3:0]read_ptr, write_ptr, counter;
  	wire fifo_empty, fifo_half, fifo_full;
  
  	always@(posedge clk) begin
  		if(rst) begin
  			read_ptr <= 0;
  			write_ptr <= 0;
  			counter <= 0;
  			fifo_out <= 0;
  		end
  
  		case({read,write})
  			2'b00:
  				counter <= counter;
  			2'b01:begin
  				if(counter == 15)begin
  					counter <= counter
  				end
  				ram[write_ptr] <= fifo_in;
  				counter <= counter + 1;
  				write_ptr <= (write_ptr == 15)? 0:write_ptr+1;
  			end
  			2'b10:begin
  				fifo_out <= ram[read_ptr];
  				counter <= counter - 1;
  				read_ptr <= (read_ptr == 15)? 0:read_ptr+1;
  			end
  			2'b11:begin
  				if(counter == 0)
  				fifo_out <= fifo_in;
  				else begin
  					ram[write_ptr] <= fifo_in;
  					fifo_out <= ram[read_ptr];
  					write_ptr <= (write_ptr == 15)? 0:write_ptr+1;
  					read_ptr <= (read_ptr == 15)? 0:read_ptr+1;					
  				end
  			end
  		endcase
  	end
  
  	assign  fifo_empty = (counter == 0);
  	assign  fifo_full = (counter == 15);
  	assign  fifo_half = (counter == 8);
  
  endmodule
  
  
  module sfifo #(parameter DW = 8, AW = 4) //数据默认宽度8位，FIFO默认深度为2^4=16。
  (clk, rst_n, write_en, data_in, read_en, data_out, fifo_full, fifo_empty);
  	input clk, rst_n, write_en, read_en;
  	input [DW-1,0]data_in;
  	output [DW-1,0]data_out;
  	output fifo_full, fifo_empty;
  
  	reg [DW-1:0]ram[(1<<AW)-1:0];
  	reg [AW:0]write_ptr, read_ptr, counter;
  	wire fifo_full, fifo_empty;
  
  	//标志位控制
  	assign fifo_full = (counter == (1<<AW)-1)? 1:0;
  	assign fifo_empty = (counter == 0)? 1:0;
  
  	//counter控制
  	always@(posedge clk, negedge rst_n)begin
  		if(!rst_n)
  			counter <= 0;
  		else if(write_en & !fifo_full & !fifo_empty & read_en)
  			counter <= counter;
  		else if(write_en & !fifo_full)
  			counter <= counter + 1;
  		else if(read_en & !fifo_empty)
  			counter <= counter - 1;
  		else 
  			counter <= counter;
  	end
  
  	//写数据
  	always @(posedge clk, negedge rst_n) begin
  		if (rst_n)
  			write_ptr <= 0;
  		else if (write_en & !fifo_full) 
  			ram[write_ptr] <= data_in;
  			write_ptr <= write_ptr+1;
  		else 
  			ram[write_ptr] <= ram[write_ptr];
  	end
  
  	//读数据
  	always @(posedge clk, negedge rst_n) begin
  		if(rst_n)
  			read_ptr <= 0;
  		else if(read_ptr == 0)begin
  			data_out <= {DW{1'bz}};
  		end
  		else if(read_en & !fifo_empty)begin
  			data_out <= ram[read_ptr];
  			read_ptr <= read_ptr+1;
  		end
  		else 
  			data_out <= data_out; 
  	end
  
  endmodule
  ```

- 异步FIFO实现代码：

  ```verilog
  //异步FIFO,宽度：8bit,深度：1024.
  
  //fifo设计的关键：产生可靠的读写指针和生成空满标志位
  
  module Async_fifo(aclk, bclk, rst_n, data_in, read_en, write_en, data_out, fifo_empty, fifo_full);
  	input aclk, bclk, rst_n;
  	input read_en, write_en;
  	input[7:0] data_in;
  	output fifo_full, fifo_empty;
  	output[7:0] data_out;
  
  	reg[10:0] write_yuan, read_yuan;	
  	wire[10:0] write_ptr, read_ptr;
  	reg[10:0] write_ptr_r, read_ptr_r;
  	reg[10:0] write_ptr_rr, read_ptr_rr;
  	reg[7:0] ram[1023:0];
  	reg[7:0] data_out;
  	//reg fifo_empty, fifo_full;
  
  	//指针逻辑+格雷码生成+fifo存储
  	always @(posedge aclk or negedge rst_n) begin
  		if (!rst_n) 
  			write_yuan <= 0;
  		else if (write_en && !fifo_full)begin
  			write_yuan <= write_yuan + 1;	
  			ram[write_yuan] <= data_in;
  		end	
  		else begin
  			write_yuan <= write_yuan;
  			ram[write_yuan] <= ram[write_yuan];			
  		end
  	end
  	assign write_ptr = (write_yuan << 1) ^ write_yuan;
  
  	always @(posedge bclk or negedge rst_n) begin
  		if (!rst_n) begin
  			read_yuan <= 0;	
  			data_out <= 0;		
  		end
  		else if (read_en && !fifo_empty) begin
  			read_yuan <= read_yuan + 1;		
  			data_out <= ram[read_yuan];
  		end
  		else begin
  			read_yuan <= read_yuan;
  			ram[read_yuan] <= ram[read_yuan];			
  		end
  	end
  	assign read_ptr = (read_yuan << 1) ^ read_yuan;
  
  	//两边指针跨时钟域同步
  	always @(posedge aclk or negedge rst_n) begin
  		if (!rst_n) begin
  			read_ptr_r <= 0;
  			read_ptr_rr <= 0;
  		end
  		else
  			{read_ptr_rr, read_ptr_r} <= {read_ptr_r, read_ptr};
  	end
  
  	always @(posedge bclk or negedge rst_n) begin
  		if (!rst_n) begin
  			write_ptr_r <= 0;
  			write_ptr_rr <= 0;
  		end
  		else
  			{write_ptr_rr, write_ptr_r} <= {write_ptr_r, write_ptr};
  	end
  
  	//根据同步后的读写指针生成标志位
  	assign fifo_full = (read_ptr_rr[10] != write_ptr[10])&& (read_ptr_rr[9] != write_ptr[9]) &&(read_ptr_rr[8:0] == write_ptr[8:0]);
  	assign fifo_empty = (write_ptr_rr == read_ptr);
  
  endmodule
  ```

- 异步设计需要关注：

  - **格雷码生成器：**

    verilog代码实现就一句：assign  gray_code = (bin_code>>1)  ^  bin_code;

  - **在格雷码域如何判断空与满？**

    判断读空时：需要读时钟域的格雷码rgray_next和被同步到读时钟域的写指针rd2_wp**每一位完全相同**;

    判断写满时：需要写时钟域的格雷码wgray_next和被同步到写时钟域的读指针wr2_rp**高两位不相同，其余各位完全相同**；

- 计算异步FIFO最小深度：

  首先，这一题目并不一定是有解的，有解的前提是要求一定时间内（T），写入的数据量要等于读出的数据量，即A/B\*wr_clk =X/Y*r_clk。

  然后，要算出写数据的最大猝发长度burst_length，考虑最坏的情况。比如若题目给出的是每100个时钟有80个数据写入FIFO，那么在**背靠背**的情况下，burst_length=2*80=160。假如题目中明显给出了数据包的传输方式，比如一个package与另一个package相隔很远，也就是互不影响，不会出现这种背靠背的情况。

  FIFO的最小深度：**fifo_depth =Burst_length - Burst_len * X/Y * r_clk/w_clk** 。Burst传输背靠背

## 20. 串并变换

- 串转并：

  ```verilog
  //单输入四输出
  module s_p(clk, rst_n, data_in, data_out);
  	input clk, rst_n;
   	input data_in;
    output reg [3:0] data_out;
    
    reg [1:0] counter;
    reg [3:0] data_out_reg;
    
    always@(posedge clk, negedge rst_n)begin
      if(!rst_n) counter <= 0;
      else counter <= counter + 1;
    end
    
    always@(posedge clk, negedge rst_n)begin
      if(!rst_n) data_out <= 0;
      else if(&counter) data_out <= {data_out_reg[2:0], data_in};
      else data_out <= data_out;
      
    always@(posedge clk, negedge rst_n)begin
      if(!rst_n) data_out_reg <= 0;
      else if(~(&counter)) data_out_reg <= {data_out_reg[2:0], data_in};
      else data_out_reg <= 0;
    end
    
  endmodule
  ```

- 并转串：多了个输出flag。

## 21. 饮料机

**题目：每瓶饮料2.5元，可投入0.5与1.0两种硬币，具有找零功能。**

解答程序：

```verilog
module drink_seller(clk, rst_n, coin_in, coin_out, drink);
	input clk, rst_n;
	input [1:0] coin_in;
	output reg coin_out;
	output reg drink;

	localparam S0 = 7'b0000001;
	localparam S1 = 7'b0000010;
	localparam S2 = 7'b0000100;
	localparam S3 = 7'b0001000;
	localparam S4 = 7'b0010000;
	localparam S5 = 7'b0100000;
	localparam S6 = 7'b1000000;

	reg [8:0] c_s, n_s;

	always @(posedge clk or negedge rst_n) begin
		if (!rst_n) c_s <= S0;
		else c_s <= n_s;
	end

	always @(*) begin
		n_s <= 'bx;
		case(c_s)
			S0: begin
				if(coin_in == 2'b01) n_s = S1;
				else if(coin_in == 2'b10) n_s = S2;
				else n_s <= S0;
			end
			S1: begin
				if(coin_in == 2'b01) n_s = S2;
				else if(coin_in == 2'b10) n_s = S3;
				else n_s <= S0;
			end
			S2: begin
				if(coin_in == 2'b01) n_s = S3;
				else if(coin_in == 2'b10) n_s = S4;
				else n_s <= S0;
			end
			S3: begin
				if(coin_in == 2'b01) n_s = S4;
				else if(coin_in == 2'b10) n_s = S5;
				else n_s <= S0;
			end
			S4: begin
				if(coin_in == 2'b01) n_s = S5;
				else if(coin_in == 2'b10) n_s = S6;
				else n_s <= S0;
			end
			S5: begin
				if(coin_in == 2'b01) n_s = S1;
				else if(coin_in == 2'b10) n_s = S2;
				else n_s <= S0;
			end
			S6: begin
				if(coin_in == 2'b01) n_s = S1;
				else if(coin_in == 2'b10) n_s = S2;
				else n_s <= S0;
			end
		endcase
	end

	always @(posedge clk or negedge rst_n) begin
		if (!rst_n) begin
			coin_out <= 0;
			drink <= 0;
		end
		else if(c_s == S5)begin
			coin_out <= 0;
			drink <= 1;
		end
		else if(c_s == S6)begin
			coin_out <= 1;
			drink <= 1;
		end
		else begin
			coin_out <= 1;
			drink <= 1;
		end
	end

endmodule
```

## 22. 乒乓buffer

提高运算速度的一种方法，用面积来换取速度的一种设计思想；比如比较大的组合逻辑单元，可以将该单元复制一份，然后接在乒乓buffer的后端，这样每个组合逻辑单元就有两个时钟周期的处理数据时间，如果是使用三个复制的逻辑单元，则每个组合逻辑单元就会有三个的时钟周期处理该数据；由此可以满足时序的要求；其实说白了也是一种变相的流水线技术！

乒乓Buffer的应用场景：当后面的处理单元在工作期间，前面的buffer的内容不能被释放（数据传输速率大于数据处理速率）。或者，在处理单元工作期间，buffer的特定地址的内容不止被访问一次。

注：对于buffer的内容用一次就可以被释放的应用场景（如处理图像数据）：直接用FIFO结构，或者移位寄存器即可实现。

可大致分为两种情况：

- 数据必须缓存完成后才能进行处理的情况。                                                                   
  - 若缓存时间大于处理时间。则加载进缓存空间的数据是连续的。处理后输出的数据不连续。                                                                    
  - 若缓存时间小于处理时间。则处理后输出的数据是连续的。加载进缓冲空间的数据是不连续的。                                                  

- 数据无须缓存完成就能进行处理的情况。                                   

  - 第一：可以考虑LineBuffer结构。而非乒乓buffer结构。                                   

  - 第二：仍采用乒乓buffer结构，加载进缓存空间的数据是连续的，且处理后输出的数据也是连续的。即：从输入端或者输出端看，数据都是连续不断的。

## 23. 时序约束

> 好博文：https://blog.csdn.net/wenjia7803/article/details/78335253

信号是通过走线和各个模块产生连接。信号通过走线必然有延迟，有人认为电信是光速走线延时应该很短，但实际情况延时会影响信号的质量。有如下因素：1.电信号在走线槽里面传播并不是光速，走线上有**分布电感和地平面有分布电容**，二者值越大，对电容充电时间越长，走线延迟越长，这写参数自然由工艺和封装来决定，和我们设计无关，但是却对我们的设计方法产生重大影响。2.除了传输线模型的延时以外，走线本身会经过很多类似路由器的结构去改变走线方向，在资源紧张的情况下可能会**走过多个路由**，这也就是为什么FPGA内部走线会很绕的原因，经过多级路由的走线延时会大大增加，在时序报告里面也可以看到的走线延迟=传输线延迟+路由延迟。3.如果设计里面组合逻辑很多那么信号就会**经过多个LUT**，这也会产生延迟，在时序报告里面可以看见组合逻辑延迟和逻辑级数这2个选项。综合以上3点，FPGA内部延时不可忽略！并且常常达到ns级！。

**所有的时序约束都是要告诉编译器，我的时钟和数据要满足怎样的关系，然后交给编译器去计算最糟糕的情况下能不能满足条件，还差多少ns就会不满足条件。**

说到FPGA时序约束的流程，不同的公司可能有些不一样。反正条条大路通罗马，找到一种适合自己的就行了。从系统上来看，同步时序约束可以分为**系统同步与源同步**两大类。简单点来说，系统同步是指FPGA与外部器件共用外部时钟；源同步（SDR，DDR）即时钟与数据一起从上游器件发送过来的情况。在设计当中，我们遇到的绝大部分都是针对源同步的时序约束问题。所以下文讲述的主要是针对源同步的时序约束。

一般来说，时序约束一共包含以下三个步骤：时钟约束、IO约束以及时序例外。

1. **首先约束时钟**，输入时钟，输出时钟。从种类来看不外乎以下几种：单端输入时钟、差分输入时钟、GT或恢复时钟(例如LVDS信号恢复出来的时钟)、PLL产生的时钟以及自己产生的门控时钟。

   - 常用指令：Create_clock、Create_generated_clock、derive pll_clocks、create_virtual_clock。

     对时钟的约束，首先要明确，我们要约束的时钟有哪些，然后针对不同的时钟进行约束。下面针对不同类型的时钟，对其约束的指令作简要分析。例如：create_clock -name SysClk -period 10 -waveform {0,5}[get_ports Clk]。

2. **IO约束**，只有等待内部时钟完全通过后，再配置input delay和output delays，告知FPGA外部端口的数据时序关系。IO的约束主要是指input_delay与output_delay这两种，编译软件（ISE/Quartus）是个很强大而又很傻的工具，在设计的时候，你务必要告诉他在FPGA外部的信号时序关系，他才能够知道怎么去优化内部的时序，以满足时序设计要求。

   - **Set Input_delay**

     从输入来看，无非有以下两种情况：SDR与DDR。

     SDR是指，数据只在时钟的上升沿更新，而DDR是时钟的上升沿与下降沿都会更新。按照时钟与数据对齐方式来划分，又可以分为沿对齐与中心对齐两种。对于输入延迟的获取，一般来说有以下三种途径：文中直接给出Tco、Tdata等参数；通过查阅上级器件的数据手册；通过示波器来实测。查上游的器件手册（主要看Tsu 与Th），那么可以推算出，FPGA输入延迟的最值，为了方便描述，这里设定时钟与数据在PCB上的传输延迟一致：

     **Input delay max = T – Tsu;**

     **Input delay min = Th;**

     当时钟与数据到达FPGA的延时不一致时，计算公式如下：

     **Input_delay_min = Th_min+ (T_data_max -T_clk_min)**

     **Input_delay_max = T-Tsu_max+ (T_data_min -T_clk_max)**

     其中T_data是数据延时，T_clk是时钟延时，由此可见在PCB布线的时候，务必让时钟与数据的走线尽可能等长。这样不容易导致时序违例现象。其中T为FPGA用于采集上游器件发送过来的数据时钟。又或者直接通过示波器观察时钟与数据的延迟关系。有些情况，例如给定了相关数值的话（Tco ,data_delay等数值），可以直接算出输入延迟。

   - **Set output_delay**
     输出延时的分析与输入延时类似。这里设定时钟与数据在PCB上的传输延迟一致：

     **output delay max =  Tsu;**

     **output delay min = -Th;**

     当时钟与数据到达FPGA的延时不一致时，计算公式如下：

     **Output_delay_min= -Th_max + (Tdata_min-Tclk_max)**

     **Output_delay_max=Tsu_max + (Tdata_max-Tclk_min)**

     其中，T_data是数据延迟；T_clk为时钟的延迟。

3. **时序例外**，在约束完时钟以及IO后，还是有时序违例的时候，注意检查一下是否有时序例外的情况，例如多周期时钟路径、异步时钟、常量、以及互斥时钟路径等等。

   - 多周期set_milticycle_path：通常情况下，两个同步的reg进行timing check时，组合逻辑的delay必须在一个时钟周期内到达，才能满足setup的时序。但在某些情况下，从一个寄存器输出到另外一个寄存器的data 端需要不止一个cycle的时间，而且又不影响逻辑的功能。此时，我们可以将这样的path约束为multicycle path。

     关于多周期路径约束博文：http://www.52-ic.com/789.html/amp

   - 不需要检测路径（常见，重要）set_false_path

   - 常量与伪常量

   - 互斥的路径

   5.异步时钟（这种情况下，务必要确保逻辑上对异步时钟域的信号做了处理，例如打两拍，FIFO等手段处理）

   5.组合电路延时，即逻辑不经过任何时钟处理就输出的情况。

## 24. 验证相关

- SV里四值变量有哪些？

  - reg（单比特或多比特的无符号数）；
  - wire（线网）；
  - time（64比特的无符号数）；
  - integer（32比特的有符号数）；
  - logic（SV改进型reg）。除了reg类型的功能外，可以用在连续赋值，门单元和模块所驱动。但是不能用在双向总线建模，不能有多点驱动。

  ![img](https://img-blog.csdnimg.cn/20190524103834628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JsZWF1Y2hhdA==,size_16,color_FFFFFF,t_70)

- SV里面动态数组、关联数组、队列各自的优缺点，应用场合。

  > 关于SV数据类型的博文：https://blog.csdn.net/haojie_duan/article/details/107971217

  - 特点：
    - 动态数组：**可以在仿真时分配空间或者调整宽度**，这样在仿真中就可以使用最小的存储量；
    - 关联数组：用来**保存稀疏矩阵的元素**，当对一个非常大的地址空间进行寻址时，SV只对实际写入的元素分配空间，比定宽和动态数组所占用的空间要小得多；
    - 队列：结合了链表和数组的优点，可以在队列的任意位置增加或删除元素，这类操作在性能上比动态数组小得多，**可以通过索引对任意元素进行访问**；
  - 应用场合：
    - 动态数组：随机事务不确定位宽的大小；
    - 关联数组：需要建立一个超大容量数组，用关联数组来存放稀疏矩阵中的元素；
    - 队列：增加元素或删除元素方便。

- function和task的区别：

  | function（草稿纸）                               | task（功能）                                             |
  | :----------------------------------------------- | :------------------------------------------------------- |
  | 函数能调用另一个函数，但不能调用另一个任务       | 任务能调用另一个任务，也能调用另一个函数                 |
  | 函数总是在仿真0时刻就开始执行                    | 任务可以在非零仿真时刻执行                               |
  | 函数一定不能包含任何延迟、事件或时序控制声明语句 | 任务可以包含延迟、事件或时序控制声明语句                 |
  | 函数至少有一个输入变量，函数可以有多个输入变量   | 任务可以没有或者有多个输入、输出和双向变量               |
  | 函数只能返回一个值，函数不能有输出或者双向变量   | 任务不返回任何值，任务可以通过输出或者双向变量传递多个值 |

- 数据的类型转换怎么做？静态强制类型转换与动态强制类型转换有什么区别？
  - 静态转换：转换时指定目标类型，并在需要转换的表达式前加上单引号即可；比如：unsigned'(signed_vec)；
  - 动态转换：使用函数$cast。
  - 区别：静态类型转换操作不对转换值进行检查，具有一定的危险性；动态转换在运行时将进行检查，如果转换失败会产生运行时错误。

-  virtual interface的作用：
  - interface只在module中声明，在class中要用virtual interface；
  - virtual interface是仿真运行时才连接到DUT上的，如果只是interface，在编译时就必须进行连接，在class中时是automatic，在运行的时候产生；
  - virtual interfacec主要完成接口的动态分配，只要在top层定义virtual interface，其它层不需要改变，直接通过interface传递参数即可；
  - 消除绝对路径，避免修改的时候改的东西很多。
- 多态：
  - 多态性（polymorphisn）是允许你将父对象设置成为一个和更多的他的子对象相同的技术，复制之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说就是允许将子类类型的指针赋值给父类类型的指针。
  - 多态的作用是为了实现接口重用，为了类在继承和派生的时候，保证使用“家谱”中任一类的实例的某一属性时的正确调用。
  - 多态的实现方法：
    - 覆盖：是指子类重新定义父类的虚函数的做法；
    - 重载：是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。

- fork join，fork join_any，fork join_none的用法

  - fork join：当前速优子进程执行完毕，才会继续执行后面的进程；
  - fork join_any：当前的任一子进程执行完毕后，才会继续执行后面的进程；
  - fork join_none：当前的子进程并不阻塞后面的进程执行。

- 阻塞赋值和非阻塞赋值的区别。

  - 阻塞赋值的操作符号用等号（=）表示，当前语句的赋值阻塞其它语句的赋值；

  - 非阻塞赋值的操作符号用小于等于号（<=）表示，当前语句的赋值不阻塞其它语句的赋值。

- Callback运行机制：

  Callback机制，其实是使用OOP来实现的一种程序开发者向程序使用者提供的模块内部的接口，可以在Test_case的高度改变其他Component的一些行为。

  对于程序的开发者而言：

  - 派生一个uvm_callback的类；
  - typedef定义一个uvm_callbacks pool；
  - 在对应的组件中注册派生的callback类。 对于程序的使用者而言：
  - 定义一个新的callback的派生子程序开发者所定义的类，并重写类的方法；
  - 在对应的test_base中实例化并添加callback的类。

- clock模块为什么要放在top module中，不放在program中的原因？

  SV介绍program的一个重要部分就是为了将涉及和验证的调度区域通过显式的方式来安排，例如设计部分被建议放置在module中，而测试采样部分被建议放置在program中，program中不能使用always，program中的仿真时间与RTL中的是有区别的，SV将同一仿真时刻分为四个区域，相当于在原verilog的基础上又为program增加了一个执行区间，一个采样区间，所以clk的定义不能放在program中。当program中的initial结束时，SV会调用$finish完成仿真。

- 谈谈对block level，chip level，product level验证的理解？

  - block level：
    - 每个模块验证首先要考虑的是哪些功能点是可以在模块一级完全验证的的，这基于如下考虑：
      - 内部功能如状态机验证；
      - 内部数据存储验证；
      - 数据打包功能、编解码功能；
      - 指令执行；
      - 寄存器配置；
    - 同时也需要考虑哪些功能无法在模块一级被验证到：
      - 与其他相邻模块的互动信号；
      - 与其他子系统的互动信号；
      - 与芯片外部的互动信号；
      - 与电源开关的验证。
  - chip level：
    - 在芯片系统级，验证平台的复用性较高，主要因为：
      - 外围的验证组件不需要像模块级、子系统级的组件数量多且经常需要更新，它们主要侧重于验证芯片的输入输出；
      - 芯片内部的子系统之间的交互、协作检查主要交给了处理器和子系统，从寄存器检查和数据检查入手，写直接测试用例。
    - 在芯片系统级的验证侧重于不同子系统之间的信号交互问题，以及实现更贴近实际使用的用例。这里的实习用例并非是在系统软件层面的，而是将> 系统软件层面的场景进一步拆分为多个模块互动情景，再分类测试的。
  - product level：
    - 直接的软件测试激励，可根据示波器等工具观察波形变化，也可以根据SDK软件debug。

-  UVM架构

- 关于fork...join,fork...join_any,fork...join_none：

  ![wETCs1.png](https://s1.ax1x.com/2020/09/05/wETCs1.png)

  简单的说就是：

  fork..join: 必须等到ment1，ment2，ment3全部执行完之后，ment4才可以执行。

  fork..join_any: 等到ment1，ment2，ment3之中任何一个执行完毕之后，ment4才可以执行

  fork..join_none: ment4的执行与否不依赖于ment1，ment2和ment3，他们可以同步执行。





## 杂项

1. 系统间信号传输方式：https://mp.weixin.qq.com/s?__biz=Mzg5MDIwNjIwMA==&mid=2247487744&idx=1&sn=49a6e51a06fc2fe69aa06216e8a58a98&chksm=cfe17397f896fa811163bbe8d2fa4da7fc611e0c0698286fc2ada2d07f7cd3dc0c72026fadbf&scene=158#rd。

2. 关于DFT：

   SoC芯片的DFT对Std Cell，Mem，I/O有不同的测试手段。

   **1.** **边界扫描测试：Boundary Scan Test**

   测试目标是IO-PAD，利用JTAG接口互连以方便测试。（很多可编程器件中都会有JTAG接口，我们往往只知道它们可以用于下载，其实还可以实现不同芯片之间的互连，可以形成整个系统的可测试性设计）。

   **2.** **内建自测试：BIST**

   模拟IP的关键功能，可以开发BIST设计。一般情况，BIST造成系统复杂度大大增加。Memory IP一般自带BIST，简称MBIST。

   **3.** **扫描测试（ATPG**）：

   SCAN技术，也就是ATPG技术。与边界扫描测试的区别，是内部移位寄存器实现的测试数据输入输出。测试目标是Std-Logic，即标准单元库。（扫描测试和边界扫描，不是一个概念。需要区别对待。内部的触发器，全部要使用带SCAN功能的触发器类型）。

   **4.** **DC/AC mode**

   我们所说的DC SCAN（Normal Scan Test） 即慢速测试，测试频率是10MHz~30MHz，AC SCAN 也就是At-Speed SCAN（Fast Scan Test）即实速测试，测试频率与芯片真实工作频率是一样的。70年代到1995年这段时间里，由于芯片的工作频率很低只有20MHz~100MHz，SCAN测试只有DC SCAN，我们就能捕捉到所有Std-Logic的制造缺陷。但是1995年以后，测试科学家和工程师发现通过DC SCAN测试没有缺陷的芯片在高工作频率下使用会有问题。其根本原因是随着制造工艺向深亚微米迈进，芯片的工作频率也提高到200MHz~1GHz，原来的SCAN测试方法和模型不再能捕捉到所有的Std-Logic的制造缺陷。

3. **典型的5级流水线RSIC结构中，5级流水线的功能分别是取指、（译码）、（执行）、（访存）、写回。**

4. 常用的**验证覆盖率**有哪些：

   语句覆盖率（statement coverage）：指的是程序的每一行代码是否被执行过。

   条件覆盖率（condition coverage）：指的是每个条件中的逻辑操作数被覆盖的情况。

   决策覆盖率（branch coverage）：指的是在if，case，while，repeat，forever，for 和loop语句中各个分支执行的情况。

   事件覆盖率（event coverage）：用来记录某一个事件被触发的次数。

   跳转（翻转）覆盖率（toggle coverage）：用来记录某个设计边界信号数据位的0/1跳转情况，例如从0到1，或者从1到0的跳转。

   状态机覆盖率（finite stage machine coverage）：仿真器的覆盖率功能可以识别出设计中的状态机部分，记录各种状态被进入的次数，以及状态之间的跳转情况。

5. **PPA是Performance，Power，Area的简称，集成电路内部的微观概念**，从1958年晶体管诞生之日起，随着摩尔定律和迪纳德定律的延续发展，集成电路的PPA成为集成电路行业最重要指标，一直在产品中强调更高的性能，更低的功耗，更小的面积（成本）。

   与集成电路内部的微观概念相对应的是**集成电路宏观的概念**，即APP。**APP是Application，Price，Property的简称**，现在对于芯片企业来讲要把芯片卖出去在微观的基础实现下，面对新的需求，需更加关注应用市场，更加关注价格甚至性价比，关注产品整体的性能参数，在碎片化的市场中寻找出路。

6. **DFT参数：**

   **MTBF（Mean Time Between Failure）为平均故障发生间隔时间**，是衡量一个产品的可靠性指标，它反映了产品的时间质量，是体现产品在规定时间内保持功能的一种能力。具体来说，是指相邻两次故障之间的平均工作时间，也称为平均故障间隔，这个平均故障时间越久说明产品故障少的就是可靠性高。

   **ATE（Auto Test Equipment）pattern count为测试机台的测试pattern数量**，pattern多意味着测试全面。

   **Fault coverage为故障覆盖率定义为在所有故障中检测到的故障的百分比**，这个指标越高越好，100%是最好的效果。

   **Yield在IC中表示芯片的良率**，即达到标称性能规格的器件或电路的百分比，这个指标是越高越好。

7. The main steps in **ASIC** Physical design flow are:

   - Design Netlist (after Synthesis);
   - Floorplanning;
   - Partitioning;
   - Placement;
   - Clock-Tree Synthesis (CTS);
   - Routing;
   - Physical Verification;
   - GDS Ⅱ Generation。

8. **VHDL不能描述开关级。**

9. 功耗计算公式：**Ptotal=Pstatic+Pdynamic. 或 Ptotal=Pleakage+Pinternal+Pswitching.**

10. **N点DFT的FFT变换可以转为log2(N)级级联的蝶形运算,每一级均包含有N/2次蝶形计算。完成一个蝶形运算需要一次复数乘法和两次复数加法。**

11. 正则表达式里可以使用计数符和通用字符集进行搜索匹配，这些计数符中， * 号的意思是匹配0个，1个或多个， + 号的意思是匹配一个或多个， ？ 的意思是匹配0个或1个。

12. 加速比：S = （Ws + Wp）/（Ws + Wp/p），Ws为程序中串行部分，Wp为程序中的并行部分，p为并行节点数。

13. 如何验证状态机完备性：从**定向测试，随机测试**两种方式中产生激励，从代码覆盖率的角度保证代码覆盖率达100%。

14. python 16进制转2进制：

    ```python
    >>> x='123abc'
    >>> b=bin(int(x,16))[2:]
    >>> print(b)
    100100011101010111100
    ```

15. 



